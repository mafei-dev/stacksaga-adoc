<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc maxdepth="5"?>
<?asciidoc-numbered maxdepth="5"?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>Introduction To Microservices</title>
<date>2023-08-29</date>
</info>
<preface>
<title></title>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="resources/img/stacksaga-logo.jpg" contentwidth="300"/>
</imageobject>
<textobject><phrase>StackSaga Logo</phrase></textobject>
</mediaobject>
</informalfigure>

<style>
.rounded-number {
    background-color: #0047b3;
    color: white;
    display: inline-block;
    padding: 0.25em 0.4em;
    font-size: 75%;
    font-weight: 700;
    line-height: 1;
    text-align: center;
    white-space: nowrap;
    vertical-align: baseline;
    border-radius: 0.5rem;
}
</style>
</preface>
<chapter xml:id="_introduction_to_microservices">
<title>Introduction To Microservices</title>
<section xml:id="_get_started">
<title>Get Started</title>
<simpara>In this section, you will get the architecture of this framework.
Other than that, you will get what are the limitations you have to face when you are going to use microservice architecture and how overcome those difficulties by using StackSAGA framework.</simpara>
</section>
<section xml:id="_microservice_architecture">
<title>Microservice Architecture</title>
<simpara>Before dive in to the framework, let&#8217;s have the basic idea of microservice architecture.
A microservice' architecture consists of a collection of small, autonomous services.
Each service is self-contained and should implement a single business capability within a bounded context.
A bounded context is a natural division within a business and provides an explicit boundary within which a domain model exists.</simpara>
</section>
<section xml:id="_what_are_microservices">
<title>What are microservices?</title>
<simpara>Microservices are a modern approach to software whereby application code is delivered in small, manageable pieces, independent of others.
<link xl:href="https://spring.io/microservices">Read more through spring microservices.</link></simpara>
</section>
<section xml:id="_database_per_service_pattern">
<title>Database per Service Pattern</title>
<simpara>One of the benefits of microservice architecture is that it lets us choose the technology stack per service.
For instance, we can decide to use a relational database for service A and opt for a NoSQL database for service B. This model lets the services manage domain data independently on a data store that best suites its data types and schema.
Further, it also lets the service scale its datastore on-demand and insulates it from the failures of other services.
However, at times a transaction can span across multiple services, and ensuring data consistency across the service database is a challenge.
In the next section, let us examine the challenge of distributed transaction management with an example.</simpara>
</section>
<section xml:id="_distributed_transaction">
<title>Distributed Transaction</title>
<simpara>To demonstrate the use of distributed transactions, we’ll take an example of an e-commerce application that processes online orders and is implemented with microservice architecture.
There is a microservice to create the orders, one that processes the payment, another that updates the inventory and the last one that delivers the order.
Each of these microservices performs a local transaction to implement the individual functionalities:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="resources/img/distributed-transaction.png" contentdepth="300"/>
</imageobject>
<textobject><phrase>distributed transaction</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>To ensure a successful order processing service, all four microservices must complete the individual local transactions. If any of the microservice fails to complete its local transaction, all the completed preceding transactions should roll back to ensure data integrity. This is an example of a distributed transaction as the transaction boundary crosses multiple services and databases.</simpara>
</section>
<section xml:id="_challenges_of_distributed_transaction">
<title>Challenges of Distributed Transaction</title>
<simpara>In the previous section, we’ve provided a real-life example of a distributed transaction. Distributed transactions in a microservice architecture pose two key challenges. The first one is maintaining ACID. To ensure the correctness of a transaction, it must be an atomic, consistent, isolated, and durable (ACID). The atomicity ensures that all or none of the steps of a transaction should complete. Consistency takes data from one valid state to another valid state. Isolation guarantees that concurrent transactions should produce the same result that sequentially transactions would have produced. Lastly, durability means that committed transactions remain committed irrespective of any type of system failure. In a distributed transaction scenario, as the transaction spans several services, it always remains a key concern to ensure ACID. The second one is managing the transaction isolation level. It specifies the amount of data that is visible in a transaction when the other services access the same data simultaneously. In other words, if one object in one of the microservices is persisted in the database while another request reads the data, should the service return the old or new data?</simpara>
</section>
</chapter>
<chapter xml:id="introduction_to_saga">
<title>Introduction to Saga</title>
<section xml:id="what_is_saga_architecture_pattern">
<title>What Is Saga Architecture Pattern?</title>
<simpara>The Saga architecture pattern provides transaction management using a sequence of local transactions. A local transaction is the unit of work performed by a saga participant. Every operation that is part of the Saga can be rolled back by a compensating transaction. Further, the Saga pattern guarantees that either all operations are complete successfully or the corresponding compensation transactions are run to undo the work previously completed. In the Saga pattern, a compensating transaction must be important and retryable. These two principles ensure that a transaction can be managed without any manual intervention. The Saga Execution Coordinator (SEC) ensures guarantees these principles:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="resources/img/compensating-transaction.svg" contentdepth="300"/>
</imageobject>
<textobject><phrase>distributed transaction</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The above diagram shows how to visualize the Saga pattern for the previously discussed online order processing scenario.</simpara>
</section>
<section xml:id="saga_orchestration_pattern">
<title>Saga Orchestration Pattern</title>
<simpara>In the Orchestration pattern, a single orchestrator is responsible for managing the overall transaction status. If any of the microservices encounters a failure, then the orchestrator is responsible for invoking the necessary compensating transactions. The Saga orchestration pattern is useful for brownfield microservice application development architecture. In other words, this pattern is suitable if we already have a set of microservices and would like to implement the Saga pattern in the application. We need to define the appropriate compensating transactions to proceed with this pattern.</simpara>
</section>
<section xml:id="eventual_consistency">
<title>Eventual Consistency</title>
<simpara>Eventual consistency is a technique that ensures data consistency and availability by asynchronous communication and ensuring that when an error occurs in a specific process, the error will be resolved eventually without having to roll back the whole process.</simpara>
</section>
<section xml:id="classification_of_saga_transactions">
<title>Classification of SAGA transactions</title>
<simpara>According to the behaviors of the transaction, we can mainly identify 3 transaction types that can be happened when we use saga.</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Fully success transaction</emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Rollback/Compensation/Revert success transaction</emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Rollback/Compensation/Revert failed transaction</emphasis></simpara>
</listitem>
</itemizedlist>
<section xml:id="fully_success_transaction">
<title><inlinemediaobject role="green">
<imageobject>
<imagedata fileref="./images/icons/circle.png"/>
</imageobject>
<textobject><phrase>circle</phrase></textobject>
</inlinemediaobject> Fully Success</title>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="resources/img/transaction-success.svg" contentdepth="300"/>
</imageobject>
<textobject><phrase>distributed transaction</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>As we discussed earlier, we had used a number of microservices for doing one single execution.
Just assume we have used 5 microservices to be executed and all of them have been worked without any errors.
Then there is no revert processes have been executed.
That means all the microservices are up and running and there haven&#8217;t been occurred exceptions internally inside each microservice.</simpara>
</section>
<section xml:id="revert_success_transaction">
<title><inlinemediaobject role="yellow">
<imageobject>
<imagedata fileref="./images/icons/circle.png"/>
</imageobject>
<textobject><phrase>circle</phrase></textobject>
</inlinemediaobject> Compensation Success</title>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="resources/img/rollback-compensation-revert-success-transaction.svg" contentdepth="300"/>
</imageobject>
<textobject><phrase>revert success transaction</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>In this time, An exception has occurred when one of microservices get execute.
Just assume the coordinator has been executed 3 microservices successfully, but at the 4th one, an error has occurred due to a network exception or whatever internal exception that the microservices have been thrown.
Now the coordinator has to execute revert function regarding all microservices that executed earlier.
So the coordinator will start to execute all the revert functions one by one as a sequence.
If those revert functions have been executed successfully, these kinds of transactions are going to these types.
Simply we did a set of transactions but unfortunately got an error, but all the revert processes are done successfully.</simpara>
</section>
<section xml:id="revert_failed_transaction">
<title><inlinemediaobject role="red">
<imageobject>
<imagedata fileref="./images/icons/circle.png"/>
</imageobject>
<textobject><phrase>circle</phrase></textobject>
</inlinemediaobject> Compensation Failed</title>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="resources/img/rollback-compensation-revert-failed-transaction.svg" contentdepth="300"/>
</imageobject>
<textobject><phrase>rollback compensation revert failed transaction</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>In this time, the coordinator tries to execute the transactions one by one.
But while doing the execution, an error occurred after doing some executions, and the coordinator gets started to execute all the revert processes that regard to the microservices that previously executed.
But unfortunately, while doing the revert executions, an error gets occurred because of a network issues.
(Network issues means it can be happened because there is no endpoint in active at that time or kind of actual network problems)</simpara>
</section>
<section xml:id="_classification_of_saga_translations_summary">
<title>Classification of SAGA translations — Summary</title>
<simpara><emphasis role="strong">Fully success transaction</emphasis></simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="resources/img/fully-success-transaction-summary.svg" contentdepth="300"/>
</imageobject>
<textobject><phrase>Fully Success Transaction Summary</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><emphasis role="strong">Rollback/Compensation/Revert success transaction</emphasis></simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="resources/img/revert-success-transaction-summary.svg" contentdepth="300"/>
</imageobject>
<textobject><phrase>Revert Success Transaction Summary</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><emphasis role="strong">Rollback/Compensation/Revert failed transaction</emphasis></simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="resources/img/revert-failed-transaction-summary.svg" contentdepth="300"/>
</imageobject>
<textobject><phrase>Revert Failed Transaction Summary</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
</section>
</chapter>
<chapter xml:id="_stacksaga_architecture">
<title>StackSaga Architecture</title>
<section xml:id="what_is_stacksaga">
<title>Introduction To StackSaga</title>
<simpara>StackSaga is an echo system that helps you to manage and monitor your distributed transactions in microservice' architecture.</simpara>
<simpara>As you saw in the &#8230;&#8203;. Section, There&#8217;s a distributed transaction problem in microservice' architecture.
So managing distributed transaction is very complicated without a framework.
StackSaga Saga provides a better and resilient architecture as an <emphasis role="strong">orchestration engine framework</emphasis> to overcome that problem with a lot of additional features as well.</simpara>
<simpara>StackSaga mainly consists of two parts.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><emphasis role="strong"><link linkend="stacksaga_admin">StackSaga Admin</link>.</emphasis><?asciidoc-br?>
StackSaga admin mainly provides the monitoring facilities of the transactions and manages the security.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">StackSaga Framework</emphasis>.</simpara>
<itemizedlist>
<listitem>
<simpara>StackSaga Framework provides orchestration engine support for your distributed transactions in your service.</simpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
<simpara><emphasis role="strong">Quick Understanding:</emphasis></simpara>
<simpara>Just imagine that you have a business domain for placing an order in microservice architecture.
So you can have multiple services, and you have to visit all over the services to complete the place-odder transaction.</simpara>
<simpara>The services might be as follows:</simpara>
<itemizedlist>
<listitem>
<simpara>Order-service</simpara>
</listitem>
<listitem>
<simpara>Payment-service</simpara>
</listitem>
<listitem>
<simpara>Cart-service</simpara>
</listitem>
<listitem>
<simpara>Delivery-Service and many more.</simpara>
</listitem>
</itemizedlist>
<simpara>IF you execute the place order process, you have to go through each and every service one by one after competing each of them.
There is no issue with that if the entire process is completed successfully all the time.
But in microservice architecture, it is not possible and there is a possibility to have an at least connection issue.
Just think all the past services are done successfully, but the last execution is failed due to insufficient balance or payment-service&#8217;s failure.
Then you have to revert (compensation-transaction) all the past executions <emphasis role="strong">one by one as the same-order</emphasis>
that those services were executed to overcome the eventual consistency according to the Saga design pattern.
It is very complicated if you are going to do manually.
Other than that, just imagine you are able to handle and bare the last failed execution, and you started to revert all the past executions one by one.
Just imagine very unfortunately, you are getting a connection error at the last revert process.</simpara>
<simpara><emphasis role="strong">Oops!</emphasis>
Now your in a big trouble with your data consistency.
Because your both transaction Forward-process and Revert-process are failed at this moment.
You can do nothing in this kind of situation.</simpara>
<simpara>You were unable to reach the target end execution to forward.
Therefore, you stated revert-process for all the past executions one by one (Last-In, First-Out order [<emphasis role="strong">LIFO</emphasis>] ).
But unfortunately, You were unable to reach the target final revert as well due to a network issue.</simpara>
<simpara>Here you can see What happened to your place-order transaction with a diagram.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="resources/img/revert-failed-transaction-intro.svg" contentdepth="300"/>
</imageobject>
<textobject><phrase>StackSaga revert failed transaction</phrase></textobject>
</mediaobject>
</informalfigure>
<orderedlist numeration="arabic">
<listitem>
<simpara>You Started the place-order transaction there.</simpara>
</listitem>
<listitem>
<simpara>Stopped the place-order transaction due to not sufficient balance.</simpara>
</listitem>
<listitem>
<simpara>Your target transaction ending for a successful transaction.</simpara>
</listitem>
<listitem>
<simpara>Started revert process due the transaction was stopped unsuccessfully.</simpara>
</listitem>
<listitem>
<simpara>The revert process was stopped due to a connection error.</simpara>
</listitem>
<listitem>
<simpara>The target revert process ending for a successful revert transaction.</simpara>
</listitem>
</orderedlist>
<simpara><emphasis role="strong">How StackSaga framework helps to overcome this problem?</emphasis></simpara>
<simpara>StackSaga provides a <emphasis role="strong">Codespaces</emphasis> (Those called as <link linkend="command_executor_architecture">Command Executor</link>,<link linkend="query_executor_architecture">Query Executor</link>) to provide your atomic operations that you did same in the place-order transaction.
The only thing that you have to do is to provide the execution-process inside the <emphasis role="strong">Codespaces</emphasis> and notify the exception type whether it is retryable or not.
Then the StackSaga engine will invoke each atomic transaction until the entire transaction gets succeeded (revert success or full process success).</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="resources/img/stack-saga-codespacess.drawio.svg" contentdepth="300"/>
</imageobject>
<textobject><phrase> Stacksaga Executors</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>In the above diagram, you can see the Codespaces for each atomic transaction.
You already might have the code portion for making the requests to other services.
In StackSaga, you can call those methods inside the <emphasis role="strong">Codespaces</emphasis>.
Then StackSaga coordinator will invoke your code portion through the <emphasis role="strong">Codespaces</emphasis>.
StackSaga does not involve your request.
Therefore, you don&#8217;t want to really on specific protocol, and you can use any protocol for making request.
At least the endpoints should not be within the same <link xl:href="https://spring.io/microservices">spring cloud ecosystem</link>.
The endpoints can be anything external or within the ecosystem.
The only thing that you want to do is make the request part of each atomic transaction and warp up with <emphasis role="strong">Codespaces</emphasis> (<link linkend="executor_architecture">executors</link>).</simpara>
<simpara>StackSaga orchestration engine follows these concepts behind the scenes.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Saga design pattern</simpara>
</listitem>
<listitem>
<simpara>Event sourcing</simpara>
</listitem>
<listitem>
<simpara>Eventual consistency.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="stacksaga_high_level">
<title>StackSaga in High-level</title>
<simpara>In the <link linkend="what_is_stacksaga">introduction section</link>, We got a clear idea of how microservice architecture works, and what are the challenges that we have to face when implementing the microservice in traditional way.</simpara>
<simpara>Here, we are going to see how the StackSaga works together with typical microservice architecture.
It shows how StackSaga does impact on the default <link xl:href="https://spring.io/microservices">spring boot microservice architecture</link>.</simpara>
<simpara>For your convenience, both <emphasis role="strong">Spring Microservice Architecture</emphasis> and <emphasis role="strong">Spring Microservice Architecture With StackSaga</emphasis> diagrams have been added here.</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Spring Microservice Architecture</emphasis> <anchor xml:id="spring_microservice_architecture" xreflabel="[spring_microservice_architecture]"/><?asciidoc-br?></simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="resources/img/microservice-high-level-diagram.svg" contentdepth="300"/>
</imageobject>
<textobject><phrase>Microservice High Level Diagram</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
<listitem>
<simpara><emphasis role="strong">Spring Microservice Architecture With StackSaga</emphasis></simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="resources/img/stack-saga-high-level-diagram.svg" contentdepth="300"/>
</imageobject>
<textobject><phrase>StackSaga High-level architecture</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
</itemizedlist>
<simpara>After adding stack saga in the microservice architecture, you can see there are some additional components in the high-level architecture diagram.</simpara>
<tip>
<simpara>In the diagram, the <emphasis role="strong">Gray</emphasis> color components and lines are related to the typical microservice architecture, and additional stacksaga related components and lines have been colored by <emphasis role="strong">Green</emphasis> color.</simpara>
</tip>
<simpara>Let&#8217;s have a look at all the components and how they are interacted with each other.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>At first glance, you can see a major difference in database architecture.
The reason is StackSaga <link linkend="SEC">SEC</link> uses <emphasis role="strong">event sourcing</emphasis> for managing your <link linkend="aggregator_architecture">aggregator state</link> for each <link linkend="executor_architecture">executor</link>.
In brief, StackSaga internally uses a database to string your execution data as events.
Therefore, If you are using StackSaga, you have to provide a database as the <link linkend="event_store">event-store</link>.</simpara>
<tip>
<simpara>Even though the diagram shows event-store per service, It can be configured as a single event-store for all services if the application is currently not a large one. <link linkend="event_store">Read more</link>.</simpara>
</tip>
<tip>
<simpara>It is recommended to use one of the StackSaga-DB implementations equal to the primary database for the particular service.
Because, you don&#8217;t need to configure another separate database and complicate the architecture.<?asciidoc-br?>
As an example, If the order-service uses <emphasis role="strong">MYSQL</emphasis> databases as the <emphasis role="strong">primary database</emphasis>, you can use the <literal>StackSaga-MYSQL</literal> implementation for the event-store.</simpara>
</tip>
<simpara>The event-store is accessed by the StackSaga framework.
Therefore, The <literal>StackSaga-Core</literal> library (StackSaga <link linkend="SEC">SEC</link> is located in this library) should be added to your application.</simpara>
</listitem>
<listitem>
<simpara>Even though it is enough for the event-sourcing, StackSaga provides more additional functionalities like avoiding <link linkend="dual_consistency_problem_of_sec_in_microservice">Dual-Consistency Problem</link>, <link linkend="stacksaga_admin">Monitoring Trace,</link> etc.
Therefore, another library should be added to your application called <literal>StackSaga-Discovery</literal>.
It will interact with your <emphasis role="strong">service-registry</emphasis> and get to know about the service availability.</simpara>
<note>
<simpara>Currently, StackSaga only supports for <link xl:href="https://spring.io/projects/spring-cloud-netflix">Eureka Service Registry</link>.</simpara>
</note>
</listitem>
<listitem>
<simpara>Next, Let&#8217;s have a look at <link linkend="stacksaga_admin">StackSaga Admin</link>.
Admin provides a lot of facilities in the framework.
Primarily feature is monitoring and tracking the transaction&#8217;s flow and trace.
For monitoring your transactions, Admin should be able to retrieve the transaction data from each event-store.
Internally, <literal>StackSaga-Discovery</literal> library provides and exposes the endpoints for that.</simpara>
</listitem>
<listitem>
<simpara>StackSaga provides a library called <literal>StackSaga-Gateway-Shield</literal> for secure your transaction-endpoints that <literal>StackSaga-Discovery</literal> library provides. <literal>StackSaga-Gateway-Shield</literal> is added as a dependency for your <link xl:href="https://spring.io/projects/spring-cloud-gateway">Spring-Cloud API-Gateway</link>.</simpara>
</listitem>
</orderedlist>
<simpara>According to the high-level architecture diagram and the brief explanation, you can identify one application and 4 libraries are involved for StackSaga.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><literal>StackSaga-Core</literal> (library).</simpara>
</listitem>
<listitem>
<simpara><literal>StackSaga-Discovery</literal> (library).</simpara>
</listitem>
<listitem>
<simpara><literal>StackSaga-DB</literal> (library).</simpara>
</listitem>
<listitem>
<simpara><literal>StackSaga-Gateway-Shield</literal> (library).</simpara>
</listitem>
<listitem>
<simpara><literal>StackSaga-Admin-Server</literal> (Application).</simpara>
</listitem>
</orderedlist>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="resources/img/architecture-stacksaga-products.drawio.svg" contentdepth="300"/>
</imageobject>
<textobject><phrase>StackSaga High-level architecture</phrase></textobject>
</mediaobject>
</informalfigure>
<itemizedlist>
<listitem>
<simpara><literal>StackSaga-Core</literal>, <literal>StackSaga-DB</literal> and <literal>StackSaga-Discovery</literal> dependencies are used for the individual service that you want to use the service as an <emphasis role="strong">orchestrator</emphasis>.</simpara>
<note>
<simpara>No need to add StackSaga for all the services in the ecosystem.
It can be added freely only to the services that you want to use.
If There is no any complex business domain in some services, there is no point in adding StackSaga for that particular service and keep it as it is in the ecosystem.</simpara>
</note>
</listitem>
<listitem>
<simpara><literal>StackSaga-Gateway-Shield</literal> is used for protecting the event-store endpoints that provide by the <literal>StackSaga-Discovery</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>StackSaga-Admin-Server</literal> Can be run as a standalone server.</simpara>
<note>
<simpara>Currently, StackSaga-Admin does support only for MYSQL.
It does not bother other services.
StackSaga-Admin&#8217;s Database is used only for saving the <emphasis role="strong">User&#8217;s-Credentials</emphasis> and the <emphasis role="strong">Terminated Transactions'</emphasis> metadata.
<emphasis role="marked">Other data that you can see in the StackSaga-Admin dashboard are obtained from each service&#8217;s event-store endpoints.
</emphasis></simpara>
</note>
</listitem>
</itemizedlist>
<simpara>We had a quit a simple idea over this high-level overview.
It is recommended to fallow the following architectures in detailed to have a better understanding.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>How <link linkend="SEC">SEC</link> does work with help of <literal>StackSaga-Core</literal> and <literal>StackSaga-DB</literal> inside the individual services.</simpara>
<simpara><link linkend="SEC">Read in detailed</link></simpara>
</listitem>
<listitem>
<simpara>How StackSaga Overcomes the <link linkend="dual_consistency_problem_of_sec_in_microservice">Dual-Consistency Problem</link> with help of <literal>StackSaga-Discovery</literal>.</simpara>
<simpara><link linkend="dual_consistency_problem_of_sec_in_microservice">Read in detailed</link></simpara>
</listitem>
<listitem>
<simpara>How StackSaga Admin communicates with each service&#8217;s event-store endpoints with help of <literal>StackSaga-Discovery</literal> and <literal>StackSaga-Gateway-Shield</literal>.</simpara>
<simpara><link linkend="SEC">Read in detailed</link></simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="key_processes_of_ecosystem">
<title>Key Processes of ecosystem</title>
<simpara>To understand the relation of those components whole process can be summarised as follows.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Initialize the admin server with super admin.</simpara>
<itemizedlist>
<listitem>
<simpara>As the first step, you have to create initialize the admin server.
See the initialization steps.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Register API gateways with admin server</simpara>
<itemizedlist>
<listitem>
<simpara>To connect the StackSaga, your API gateway should provide an API-gateway-user credentials.
Therefore, super Admin should create a user with API gateway authorization (role).
After creating the API gateway user, the api gateway can be run because StackSaga Shield will check your credentials connecting with the admin server.
For this process, StackSaga server and StackSaga Shield were involved.
See the implementation to see more in detail.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Register each microservice with admin server.</simpara>
<itemizedlist>
<listitem>
<simpara>To register the services in the admin server, the super admin or admin has to create a user for service with service privileges.
As a best-practice, the StackSaga team recommends you to create one user for one service group.
(A service group can have multiple instances, but the service names are the same.) For instance, order-service should have a service user called order-service-general-user.
And payment service should have a service user called payment-service-general-user.
At the start-up, the connector will verify your service credentials and let you the access to register and run the service.
For this process, StackSaga Server and StackSaga Connector were involved.
See the implementation to see more in detail.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Execute a transaction.</simpara>
<itemizedlist>
<listitem>
<simpara>This is the main part that you are willing to see.
The request comes through the API gateway as usual, and the StackSaga coordinator will obtain the request data that you pass, and the coordinator will handle all the process and executions as you have guided the framework.
For this process only StackSaga coordinator was involved.
Read the implementation Or read how stack saga execution types work to see more, in detail.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Monitor transactions execution data.</simpara>
<itemizedlist>
<listitem>
<simpara>To see the execution data, you should have to have a user account on the admin server.
If you are the super admin, the super admin can see all the details.
But as a best-practice, make sure to create a separate individual account for each user that wat to access the admin server to see the transaction data.
After login to the dashboard, you have to give the access path of the API gateway that you want to access the services.
You will be able to see the transaction data.</simpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
<simpara>For this process, StackSaga server, StackSaga Shield and StackSaga Connector were involved.</simpara>
</section>
<section xml:id="stack_saga_admin_connect_with_event-store">
<title>Admin Communication With Event-store</title>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="resources/img/architecture_stacksaga_how_admin_dashboard_access_stacksaga_endpoint.drawio.svg" contentdepth="300"/>
</imageobject>
<textobject><phrase>StackSaga High-level architecture</phrase></textobject>
</mediaobject>
</informalfigure>
<orderedlist numeration="arabic">
<listitem>
<simpara>Admin sends the request to access the event-store data from the admin-dashboard (<literal>/stacksaga/**</literal>) with the admin-user credentials.</simpara>
</listitem>
<listitem>
<simpara>spring API-gateway catches the request and check the mapping. if the request is starting prefixed with <literal>/stacksaga</literal>, the request goes through the <emphasis role="strong">StackSaga Shield</emphasis>'s filter. then the filter will communicate with the stacksaga admin server with the admin-user credentials and also with the Api-Gateway-user credentials.</simpara>
</listitem>
<listitem>
<simpara>StackSaga admin received the request and checks the both credentials.</simpara>
</listitem>
<listitem>
<simpara>StackSaga admin sends the response the credentials are valid or not.
v If the request credentials are validated, Api-Gateway sends the request to one of available service instances (x-Service).<?asciidoc-br?></simpara>
</listitem>
<listitem>
<simpara>The service will rerun the data set to the incoming request.
(The endpoint will be provided by the StackSaga connector.)</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="stacksaga_components">
<title>StackSaga Components</title>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="stacksaga_admin_index">StackSaga Admin</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="stacksaga_core_index">StackSaga Starter Core</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="stacksaga_starter_db_index">StackSaga Starter DB</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="stacksaga_starter_discovery_index">StackSaga Starter Discovery</link></simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="SEC">
<title>Saga execution coordinator (SEC)</title>
<simpara>The Saga Execution Coordinator (SEC) is the core component for implementing a successful Saga flow.
It maintains a Saga log that contains the sequence of events of a particular flow.
If a failure occurs within any of the components, the SEC queries the logs and helps identify which components are impacted and in which sequence the compensating transactions must be executed.
Essentially, the SEC helps maintain an eventually consistent state of the overall process.</simpara>
<simpara>If the SEC component itself fails, it can read the SEC logs when coming back up to identify which of the components are successfully rolled back, identify which ones were pending, and start calling them in reverse chronological order.</simpara>
<itemizedlist>
<listitem>
<simpara>Stores &amp; interpret a Saga’s state machine</simpara>
</listitem>
<listitem>
<simpara>Executes the Requests of a Saga by talking to other services</simpara>
</listitem>
<listitem>
<simpara>Handle failure recovery by executing Compensating Requests</simpara>
</listitem>
</itemizedlist>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="resources/img/stack-saga-e-store-example-SEC.drawio.svg" contentdepth="300"/>
</imageobject>
<textobject><phrase>StackSaga  Saga Execution Coordinator (SEC)</phrase></textobject>
</mediaobject>
</informalfigure>
<note>
<simpara>If you want to see how SEC works for each transaction mode in detail, please refer <link linkend="stack_saga_transaction_type">StackSaga Transaction Types</link>.
It will give you a better understanding of StackSaga framework as well.</simpara>
</note>
</section>
<section xml:id="event_store">
<title>Event Store</title>
<simpara>Event-store is the location that StackSaga stores the data Relevant to the transaction execution as well as the storing the metadata of the components that you provided like <emphasis role="strong">aggregator details</emphasis>, <emphasis role="strong">executor details</emphasis>, <emphasis role="strong">application version details</emphasis> etc. all the data you can see through the <link linkend="stacksaga_admin">StackSaga Admin dashboard</link>.
You can configure the database for the event-store as the pattern of database per service.
Otherwise, you can provide one event-store for all services.
But as the best practice, event-store per service is recommended.
You can define a separate schema for event-store by providing the configurations.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>One Event-Store Per Service.</simpara>
</listitem>
<listitem>
<simpara>One Common Event-Store For All Services.</simpara>
</listitem>
</orderedlist>
<section xml:id="one_event_store_per_service">
<title>One Event-Store Per Service.</title>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="resources/img/Architecture-Stacksaga-event-store-per-service.drawio.svg" contentdepth="300"/>
</imageobject>
<textobject><phrase>StackSaga Event Store Per Service</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="single_event_store_for_all_services">
<title>Single Event-Store For All Services.</title>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="resources/img/Architecture-Stacksaga-one-event-store-for-all-services.drawio.svg" contentdepth="300"/>
</imageobject>
<textobject><phrase>StackSaga Event Store For All Service</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="the_requirement_of_the_event_store">
<title>The requirement of the event-store</title>
<simpara>StackSaga framework provides the SEC capabilities.
Then the framework has to store each execution data (aggregator state and the transaction information like that each sub transaction was failed or success, etc.) The interesting part is how the framework saves each state of the whole transaction process.
As the initial step, the transaction is saved in the event store with initial data that you provided with the relevant aggregator.
After the saving the INIT step, the first executor is invoked and after invoking the executor, the framework saves the new updated aggregator state in the event store.
Likewise, after all and every steps the updated aggregator state and the execution state are saved in the event-store.</simpara>
</section>
<section xml:id="_what_are_the_reasons_for_saving_the_states_in_the_event_store">
<title>What are the reasons for saving the states in the event-store?</title>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">To retry purpose.</emphasis></simpara>
<simpara>Any kind of execution can retry if the execution is failed due to a <link linkend="retryable_executor_exception">retryable-exception</link> like network exception.
Because if an execution is failed due to a network error, it is not fair that it is treated as an exception in the microservice architecture.
Because one transaction consists of multiple individual transactions and any time one service may have gone down.
Therefore, retrying the execution is one of the main features that StackSaga provides.
StackSaga always considers the <link linkend="eventual_consistency">eventual consistency</link>.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">To see each and every step and their changes by using the StackSaga <link linkend="stacksaga_admin">Admin Dashboard</link>.</emphasis></simpara>
<simpara>You can see how the aggregator was changed while each sub process of the transaction which transactions were failed or which transaction is pending to the execution and which transaction has been successfully done, etc.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="aggregator_architecture">
<title>Aggregator</title>
<simpara>An <emphasis role="strong">aggregator</emphasis> is the main location that all the data should be kept for the entire transaction.
According to the StackSaga example, the entire process has set pf sub processes.
Create order, check user activeness, make payment, increase points and dispatch the order.
While those processes, you have to keep some data regarding the transaction.
For instance, the process is started from creating order.
After creating the order, you have a data to be kept.
As a response, you will get the order id.
You have to keep it, and you have to reuse it in your whole process.
After creating the order, you check the user activeness.
Then the user service is called and get the response of user&#8217;s activeness and keep that data as user is active at the time of the process started.
Likewise, each and every process will return you to data.
Those data you have to keep in one location.
That location called as the aggregator.
At the start, you have to declare the variables, and after doing each process, you can update the values in the aggregator.
On the other hand, we can say it is the data bucket that you bring the data to each executor.</simpara>
<simpara>Another special thing is that the aggregator is used as the key of your entire transaction.
That means the executors are identified by the aggregator class that you use.
Because your entire transaction can have only one aggregator.
Therefore, the aggregator class is used in each and every time by representing the transaction.
For instance, according to the StackSaga example, the place order is the entire process.
It contains many sub processes like create order, check user ect.
Each process is introduced to the framework by using executors.
So, for each process have separate executors.
When you create each executor, you should mention what ks the aggregator that you want to use in that executor.</simpara>
<note>
<simpara>You can store/update the data in the aggregator by using the process execution only (doProcess()).
If you want to keep some metadata while your revert/compensation processes, you can use the hint-store that the framework provides.</simpara>
</note>
</section>
<section xml:id="executor_architecture">
<title>Executor</title>
<simpara>According to the saga design pattern, you have to separate your entire transaction in to small atomic transactions.
In general, each atomic execution can have two executions called <emphasis role="strong">process execution</emphasis> and <emphasis role="strong">compensation execution</emphasis>.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><emphasis role="strong">Process Execution / Main Execution</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>The main execution that you want to archive the atomic transaction.<?asciidoc-br?>
<?asciidoc-br?>
As an example, In your <link linkend="what_is_stacksaga">place order example</link> you had multiple individual processes to overcome the entire transaction like checking use&#8217;s validation, checking stock&#8217;s availability, updating stock, making payment, dispatching the order.
Those executions that caused to start the atomic processes are called as <emphasis role="strong">Process execution</emphasis>.<?asciidoc-br?>
Those are going forward [<inlinemediaobject role="green">
<imageobject>
<imagedata fileref="./images/icons/arrow-circle-right.png"/>
</imageobject>
<textobject><phrase>arrow circle right</phrase></textobject>
</inlinemediaobject>].</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis role="strong">Compensation Execution / Revert Execution</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>Most of the <emphasis role="strong">Main Executions</emphasis> can have a revert process to undo the executions that were done before If you want to get state back of your changed data (Because you can&#8217;t do rollback just like you do in the Monolithic application).
The executions that are used for the reverting the done-process before are called as <emphasis role="strong">Compensation Executions</emphasis>.<?asciidoc-br?>
<?asciidoc-br?>
As an example, If the stock-updating process was done successfully but due to one of the next atomic executions' failures, the stock-updating execution should be restored (Undo the process or get the state back).<?asciidoc-br?>
If the main execution has a revert execution, Those are going backward [<inlinemediaobject role="green">
<imageobject>
<imagedata fileref="./images/icons/arrow-circle-left.png"/>
</imageobject>
<textobject><phrase>arrow circle left</phrase></textobject>
</inlinemediaobject>].</simpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
<note>
<simpara>Even though most of the executions can have a Compensation Execution / Revert Execution, Sometimes it is not.
It is based on your nature of the execution.
It can be explained by the CRUD operations.
If your atomic execution cased to a database&#8217;s state change, That kind of executions can have a revert execution to get the state back. <?asciidoc-br?>
As an example, In the above example, <emphasis role="strong">checking use&#8217;s validation, checking stock&#8217;s availability</emphasis> executions have no revert executions.
Because that were only read operations.<?asciidoc-br?></simpara>
</note>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Process Execution</entry>
<entry align="left" valign="top">Has a Revert</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">C</emphasis> - Create</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">YES</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">R</emphasis> - Read</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">NO</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">U</emphasis> - Update</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">YES</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">D</emphasis> - delete</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">YES</emphasis></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>To hand over your set of atomic transactions regarding the entire transaction to the <link linkend="SEC">SEC</link>, you have to identify whether the atomic transaction has a revert operation or not.
Because StackSaga framework does provide tow Codespace types for setting up each atomic execution.</simpara>
<simpara>According to the framework, those <emphasis role="strong">Codespaces</emphasis> are called as <emphasis role="strong">Executors</emphasis>.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="query_executor_architecture">Query executors</link></simpara>
<itemizedlist>
<listitem>
<simpara>If some atomic process has no compensation (query execution), those kinds of processes are used in a query executor.<?asciidoc-br?>
— In <emphasis role="strong">Query Executor</emphasis> has only one <link linkend="query_executor">method</link> for making the main process.</simpara>
<simpara><emphasis role="strong">Example</emphasis>: If you want to check, the user is active at the time of the transaction happen, and you want to keep the user&#8217;s activeness until the end of the transaction.<?asciidoc-br?>
<?asciidoc-br?>
<link linkend="query_executor">Implementation</link>|<link linkend="query_executor_architecture">Read More</link></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><link linkend="command_executor_architecture">Command executors</link></simpara>
<itemizedlist>
<listitem>
<simpara>If some atomic process has a compensation (command execution), those kinds of processes are used in a command executor.<?asciidoc-br?>
— In <emphasis role="strong">Command executor</emphasis> has two <link linkend="command_executor">methods</link> for making the main process and making the revert process.</simpara>
<simpara><emphasis role="strong">Example</emphasis>: Think that you want to create an order and order process is done successfully.
But after the make-payment process is failed.
Then the compensation process will be started.
Now you must have a compensation against the creating order.
So create an order process is a command process, and it goes to a command executor.<?asciidoc-br?>
<?asciidoc-br?>
<link linkend="command_executor">Implementation</link> | <link linkend="command_executor_architecture">Read More</link></simpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
<simpara>The below diagram shows the Executors types and what are the methods they have.
To see how you can implement these executors, <link linkend="saga_executors">read here</link>.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="resources/img/stack-saga-e-store-example-executor-types-in-stacksaga.drawio.svg" contentdepth="300"/>
</imageobject>
<textobject><phrase>Stacksaga Executors</phrase></textobject>
</mediaobject>
</informalfigure>
<section xml:id="query_executor_architecture">
<title>Query Executor</title>
<simpara>In the query executor, you only have a one method to do your atomic execution.
It&#8217;s called as atomic process execution.
Upon the aggregator that you provided you will have the aggregator as a parameter.
That is the aggregator object which runs for the entire transaction.
In the method, you are permitted to read write and update the values from that object.
And you can invoke your atomic execution inside the method body by using the values of given aggregator.
According to the StackSaga example, just think we are going to check the user status.
To do this part, you already have the service class and the function.
For here, the only thing that you do is introduction that method and get the relevant data from the given aggregator.
The framework is responsible for invoking that method you mentioned. ** In one executor, you can introduce one atomic process only.</simpara>
<simpara>Finally, you have to return what is the next executor that you want to execute.
It is totally runtime.
You can decide it the data by using the given aggregator or by anything else.
Or, if your process is completed from this execution, you can notify about that by complete single.</simpara>
</section>
<section xml:id="command_executor_architecture">
<title>Command Executor</title>
<simpara>In the command executor, you will have two methods to be implemented.
One for the process the transaction forward.
And another one for its compensation.
Now you know what you can do inside the doProcess.
Let&#8217;s talk about the doRevert method.
This is the location that you can execute your compensation atomic transaction.
For here, you will have the final status of the aggregator.
What is the final status of the aggregator?
It means the aggregator will change on each and every executor&#8217;s doProcess method.
Some values are added and some values can be changed.
Just think the aggregator was used for 10 sub processes.
But the target processes are 20.
But the process can&#8217;t be executed further more due to the error that occurred at step number 10. That means old 9 steps (sub executions/ sub transactions) have been done successfully.
But 10 was failed.
The framework ignores the changes of the step number 10.
Because the atomic transaction is failed and updated data is not valid due to the failure.
Therefore, in the <literal><emphasis role="strong">doRevert</emphasis></literal> method, you will get the aggregator object that was before going to be executed at step number 10.
For instance, if you change the value of xyz variable as 2, but in the step number 9, the value of xyz is null.
Because you have set the value then.
Then step number 10 is failed.
So the final aggregator that you will be given is xyz = null.
In the revert method, you are not permitted to change the data.
Because it is the final status of the aggregator.
It should be immutable and all the revert methods should use the data to process the compensation.
Due to having the getters and setters, you can set the values and change the values by using the reference.
But the framework ignores those updates.
Another special thing is that the <emphasis role="strong"><literal>revert</literal></emphasis> method doesn&#8217;t have a return.
Because the framework knows the order of the revert executions, and you can&#8217;t change the direction.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="resources/img/Architecture-Stacksaga-command-executor-with-revert-executors.drawio.svg" contentdepth="300"/>
</imageobject>
<textobject><phrase> Stacksaga Executors</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_how_executors_behave_in_the_application">
<title>How Executors Behave In The Application.</title>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="resources/img/stack-saga-e-store-example-what-is-executor-in-stacksaga.drawio.svg" contentdepth="300"/>
</imageobject>
<textobject><phrase> Stacksaga Executors</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
</section>
<section xml:id="aggregator_and_executors">
<title>Relationship between Aggregator and Executors</title>
<simpara>Here you can see all the sub sets of processes are connected with the aggregator.
Each sub process wants the aggregator to get run.
That means the data that executor wants to execute the sub process, is located at the aggregator.
If some executor is not linked with the aggregator, it is not configured in the framework.
You can see the executor-introduction or the real implementation of the example to learn more about the executors.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="resources/img/stack-saga-e-store-example-aggregator-and-executors.drawio.svg" contentdepth="400"/>
</imageobject>
<textobject><phrase>StackSaga Aggregator And Executors</phrase></textobject>
</mediaobject>
</informalfigure>
<section xml:id="aggregator_usage_with_executor">
<title>How the Aggregator is used through the Executors</title>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="resources/img/stack-saga-e-store-example-aggregator-state.drawio.svg" contentdepth="300"/>
</imageobject>
<textobject><phrase>StackSaga Aggregator And Executors</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
</section>
<section xml:id="version_casting_architecture">
<title>Version Casting</title>
<simpara>All the applications will be updated by changing their versions from time to time.
When a new version is deployed, the old version will be replaced by the new version (if you are not going to use service-mesh).
But in the event-based architecture, some events can have been waiting to be executed when the new version is being deployed or after deployed as well.
Then the old event should be mapped with the previous version.
And if you don&#8217;t consider the old version’s execution, when developing the new version, the events will be conflicted or crashed.
Because, the old version&#8217;s event is going to be executed by using the new version of the same service.
But the new version doesn&#8217;t allow the old events, and then the event will face for an exception due to that the event&#8217;s data is not mapped with different versions to be executed smoothly.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="aggregator_oriented_casting_architecture">Aggregator-Oriented casting</link></simpara>
<orderedlist numeration="lowerroman">
<listitem>
<simpara>Aggregator upcast</simpara>
</listitem>
<listitem>
<simpara>Aggregator downcast</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara><link linkend="executor_oriented_casting_architecture">Executor-Oriented casting</link></simpara>
<orderedlist numeration="lowerroman">
<listitem>
<simpara>Executor upcast</simpara>
</listitem>
<listitem>
<simpara>Executor downcast</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<section xml:id="aggregator_oriented_casting_architecture">
<title>Aggregator-Oriented casting</title>
<simpara>All the newly added changes to the aggregator of the new version are called as` aggregator-oriented changes.
And then, as a developer, you have to do some casting /mapping between those aggregator versions to avoid that conflict.
But it is not a complicated task because that, the framework uses the Jackson library for serialization.
(Storing events in the database.) Therefore, you can follow the same effort what you have been doing with Jackson mapping as usual.</simpara>
<simpara>For instance, the old version&#8217;s aggregator has 3 fields, and the new version can have 4 fields or more than that, or else, the new version can have 2 fields.
That means the aggregator has got changed relatively to the old version.
If the new aggregator has more values than the previous one, those kinds of updates are called as upcasting.
According to the example, the event-store might have the old events consisting of 2 fields.
And if the new version has a less number of fields than the old one, it is called as down-casting.
Now those remaining events are going to be executed through the new version.
And the framework tries to build the new aggregator object by using the old event&#8217;s binaries.
This is the time the casting is been worked on.
You have to modify and annotate the aggregator so as not to conflict while building the object by the framework.
Here you can see the best practices related to the casting of aggregators.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><emphasis role="strong">Up-Casting</emphasis></simpara>
</listitem>
</orderedlist>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="resources/img/Architecture-Stacksaga-aggregator-version-up-casting.drawio.svg" contentdepth="300"/>
</imageobject>
<textobject><phrase> Stacksaga aggregator version up-casting</phrase></textobject>
</mediaobject>
</informalfigure>
<orderedlist numeration="arabic">
<listitem>
<simpara><emphasis role="strong">Down-Casting</emphasis></simpara>
</listitem>
</orderedlist>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="resources/img/Architecture-Stacksaga-aggregator-version-down-casting.drawio.svg" contentdepth="300"/>
</imageobject>
<textobject><phrase> Stacksaga aggregator version down-casting</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="executor_oriented_casting_architecture">
<title>Executor-Oriented Casting</title>
<simpara>According to the framework, one aggregator can have multiple executors based on your use case.
When you update the version of the service, you might want to remove existing executors or add new executors based on the update that should be done.
If you are going to add more additional executors to the existing aggregator that is called as <emphasis role="strong">executor-oriented upcasting</emphasis>.
And the opposite of that, if you remove some existing executors from the aggregator, that form is called as <emphasis role="strong">executor-oriented-down-casting</emphasis>.
Adding more is not a problem when the old event executors at all.
Just think, for instance, the old aggregator had 3 executors and the new aggregator has 4 executors due to the additional one, which has been added.
And after deploying the new version, the old events are executed through the new version.
That execution is not conflicted because, all the necessary executors are in the new version.</simpara>
<note>
<simpara>IF there is an executor down-cast scenario, This time is not just like Executor-oriented-down-casting because the old event should have all the expected executors to be executed as you plan that event should be executed upon the old version&#8217;s use case.
But in the new version, if one or more executors do not exist, most of the time the execution can be crashed.
(In rare cases, it might not be affected upon your update) by the way, even though you want to use some executors for the previous version and for the new version that executor is not used, that kind of situation is called as executor-oriented down-casting changes.
To avoid conflict in this way, the framework provides a feature to skip the old executor from the latest version, and the old executor is retained only for the remaining old events as it&#8217;s.
== up-casting</simpara>
</note>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="resources/img/Architecture-Stacksaga-executor-oriented-version-up-casting.drawio.svg" contentdepth="400"/>
</imageobject>
<textobject><phrase>Architecture Stacksaga executor-oriented version up-casting</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
</section>
<section xml:id="dual_consistency_problem_of_sec_in_microservice">
<title>Dual-Consistency problem of SEC in microservice.</title>
<simpara>In the microservice architecture, It is highly concerned about the data consistency.
As a result of that, you had to move in to the <link linkend="introduction_to_saga">SAGA design pattern,</link> and it ensures eventual consistency.</simpara>
<simpara>But you know that <link linkend="SEC">SEC</link> also uses a database internally for storing the event data for retry purpose in StackSaga.
SEC is also another program that supports for your execution as a middleware framework.
That means that all the executions are saved in the database as an event by the StackSaga framework before the real execution.
Because, in case your atomic transaction is failed for some reason, the atomic transaction should be retried by the SEC.
To do re-play, the old state should be in the hand of the StackSaga.</simpara>
<simpara>Your entire domain has 5 atomic transactions inside the StackSaga <link linkend="executor_architecture">executors</link>.
StackSaga starts execution one by one as you configured.
Then before executing the transaction, the transaction should be initialized in the event-store.
In that case, StackSaga uses the event-store to store the event data at the 1st time in the transaction execution.
After successfully saving the initial event data, you will have a transaction id (<link linkend="creating_aggregator_class">aggregatorTransactionId</link>).
And after that, your 1st executor will be executed by the SEC.
After executing your 1st atomic transaction, again the updated state is saved in the event-store by SEC.
Like so, all the time your state is saved in the event-store.
Then just think that after executing the 2nd atomic transaction (execution) SEC going to update the event-store and then an error is occurred due to connection issues of the event-store database.</simpara>
<simpara>Then the framework is failed to provide the data consistency by themselves of their side.
But the real fact, the first reason is for choosing a framework is to overcome the data consistency.
But If the framework is not capable of handling the data consistency by itself, there is no point in using a framework.</simpara>
<simpara><emphasis role="marked">In brief, The responsibility of protecting both data-consistency of internal event-store and your transaction&#8217;s data-consistency is known as the Dual consistency problem of SEC.
</emphasis></simpara>
<simpara>In the stack saga framework, to avoid this consistency issue, a solution is provided.</simpara>
<simpara>The solution the frame provides.
As mentioned above, if the database goes down when executing an executor and tries to save the state in the event-store, the framework doesn&#8217;t give up the process due to the database error.
Because, the framework has the responsibility to keep the data consistency anytime.
Because the framework is also built to take care of the data consistency, then the framework can&#8217;t forget their data consistency as well.</simpara>
<simpara>Then, after trying to save the event-data in the event store, the SCE gets known the there is a database connection loss.
Then SCE convert the whole dataset (the dataset that tried to save in the database) regarding the event to binary file in the application scope&#8217;s file system (in spring boot, it can be the resource folder) to keep data in persist.
The file is saved as temporary.
After saving the temporary file, the SEC transfers that file into the admin database through the Redis server immediately.
Because in the microservice' architecture, the server instance does not persist.
The reason is that the server instance is built automatically based on the load in the individual containers.
That&#8217;s why the saved file immediately transfers to the admin database.
Then that file will be saved in the database as binary.</simpara>
<simpara>After saving the data file in to the admin database, the admin server tries to invoke by using another randomly selected same microservice.
The instance is not a problem here because one service can have the same multiple instances.
Then one of the same services can invoke that data file if the database connection is successful.
If there is no any instance instead of that, the admin server keeps waiting for connection is successful.
After that, the connection is back to normal, the admin server will push the file in to one of the services and invoke the file.
After invoking the file data successfully, the particular service will push a message to the admin server to delete the saved file.
Because after invoking the file, there is no point in saving that file in the admin server.
It should be deleted.
Because if the file data exists in the admin database, the admin server try to invoke it again.
That&#8217;s how the framework handles its data consistency while keeping the client&#8217;s data consistency as well.
It is true that the possibility is very rare but just think that if it happens, that issue the transaction processes will not be complete and the transaction can&#8217;t archive the eventual consistency as well.
As a programmer, I think this is the main advantage of using StackSaga framework.
Now, if you have a doubt, what happens if the admin server is not up and running?
It doesn&#8217;t matter.
If it occurred that kind of situation and one of the services try to send a file into admin server while the admin server is down, the file is kept by the relevant instance until the admin server is up.
When the admin server goes up, the instance will know about and then the instance will push the file into the admin server as usual.
Now you can have a problem in your mind.
What happens if the admin server is down and the relevant instance is also going to be down.
Then what will happen to that saved file?
The framework has considered that as well.
Normally, the instances are down by stopping the application server.
Then the framework doesn&#8217;t give a chance to stop the server until push that kind of saved files are transferred.
The server keeps waiting until the admin server goes up.
Those files can be missing only you kill the application by forcing.</simpara>
<literallayout class="monospaced">+</literallayout>
</section>
<section xml:id="stack_saga_transaction_type">
<title>StackSaga Transaction Types</title>
<simpara>In this section, you will get the architecture of this framework.
Other than that, you will get what are the limitations you have to face when you are going to use microservice architecture and how to overcome those difficulties by using StackSAGA framework.</simpara>
<simpara>You know that in the saga flow, the transaction can be divided into 3 types according to the behavior of the transaction.
Let&#8217;s see one by one how the StackSaga&#8217;s execution-coordinator coordinates (SEC) each component with each transaction type.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><emphasis role="strong"><link linkend="fully_success_transaction_scenario">Fully success transaction scenario</link></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong"><link linkend="revert_success_transaction_scenario">Revert success transaction scenario</link></emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong"><link linkend="revert_failed_transaction_scenario">Rollback/Compensation/Revert failed transaction scenario</link></emphasis></simpara>
</listitem>
</orderedlist>
<section xml:id="fully_success_transaction_scenario">
<title><inlinemediaobject role="green">
<imageobject>
<imagedata fileref="./images/icons/circle.png"/>
</imageobject>
<textobject><phrase>circle</phrase></textobject>
</inlinemediaobject> Fully Success</title>
<simpara>here, the SEC has successfully executed all the executors. therefore, there is no compensation/revert execution was invoked. this is the success scenario we wish.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="resources/img/Architecture-Stacksaga-fully-success-transaction-stacksaga.drawio.svg" contentdepth="300"/>
</imageobject>
<textobject><phrase>StackSaga High-level architecture</phrase></textobject>
</mediaobject>
</informalfigure>
<itemizedlist>
<listitem>
<simpara><span class="rounded-number">1</span> As the first step the user makes the request and the <emphasis role="strong">OrderController</emphasis> catch the request.</simpara>
</listitem>
<listitem>
<simpara><span class="rounded-number">2</span> After having the request, initialize the place order aggregator and set the start executor into the StackSaga.
(In this time you have the transaction uid which is created by framework.
The transaction uid is the unique id for identifying each transaction.
You can get it from your created Aggregator object.)</simpara>
</listitem>
<listitem>
<simpara><span class="rounded-number">3</span> now the execution processes are handled by the SEC.
Before invoking the executor that you provided as the start-executor SEC saves the initial state of the aggregator in the event-tore.</simpara>
</listitem>
<listitem>
<simpara><span class="rounded-number">4</span> SEC executes the start-executor<emphasis role="strong"> ([Command] CreateOrderExecutor)</emphasis> that you provided. <span class="rounded-number">4.1</span> due to the executing the process method by the SEC, the <emphasis role="strong">InternalOrderService&#8217;s</emphasis> <emphasis role="strong">createOrder()</emphasis> method will be invoked. <span class="rounded-number">4.2</span> after successfully invoking the method, SEC will store the state of the aggregator. <span class="rounded-number">4.3</span> after saving the state in the event-store, SEC will execute the <emphasis role="strong">onEachProcessPerformed</emphasis> method of the handler class that you provided. <span class="rounded-number">4.4</span> then you can put your execution here to update the status of the place-order transaction. as the diagram, we have executed <emphasis role="strong">updateCustomerOrderStatus()</emphasis> method of <emphasis role="strong">InternalOrderService</emphasis> to update the status. <span class="rounded-number">4.5</span> after updating the status of the place-order, you can notify your customer by sending the email or SMS or whatever method about the status of the order.</simpara>
</listitem>
<listitem>
<simpara><span class="rounded-number">5</span> SEC executes the 2nd executor that you provided from the 1st executor. <span class="rounded-number">5.1</span> due to the executing the <emphasis role="strong">doProcess</emphasis> method of the <emphasis role="strong">[Query] UserExecutor</emphasis> by the SEC, the <emphasis role="strong">ExternalUserStatusService&#8217;s</emphasis> <emphasis role="strong">checkUser()</emphasis> method will be invoked.
<span class="rounded-number">5.2</span> the <emphasis role="strong">ExternalUserStatusService</emphasis> will call the <emphasis role="strong">user-service</emphasis> and make a request.
<Span class="rounded-number">5.3</span> after successfully invoking the request, SEC will store the state of the aggregator of 2nd process. <Span class="rounded-number">5.4</span> after saving the state in the event-store, SEC will execute the <emphasis role="strong">onEachProcessPerformed</emphasis> method of the handler class that you provided.</simpara>
<simpara><emphasis role="marked">Due to this executor is a query executor, there is no status update process has been executed here.</emphasis></simpara>
</listitem>
<listitem>
<simpara><span class="rounded-number">6</span> SEC executes the <emphasis role="strong">[Command] PaymentExecutor</emphasis> executor that you provided. <span class="rounded-number">6.1</span> due to the executing the process method by the SEC, the <emphasis role="strong">ExternalPaymentService&#8217;s</emphasis> <emphasis role="strong">makePayment()</emphasis> method will be invoked. <span class="rounded-number">6.2</span> the <emphasis role="strong">ExternalPaymentService</emphasis> will call the <emphasis role="strong">payment-service</emphasis> and make a request to make-payment process. <span class="rounded-number">6.3</span> after successfully making the request, SEC will store the state of the aggregator. <span class="rounded-number">6.4</span> after saving the state in the event-store, SEC will execute the <emphasis role="strong">onEachProcessPerformed</emphasis> method of the handler class that you provided. <span class="rounded-number">6.5</span> then you can put your execution here to update the status of the place-order transaction. as the diagram, we have executed <emphasis role="strong">updateCustomerOrderStatus()</emphasis> method of <emphasis role="strong">InternalOrderService</emphasis> to update the status. <span class="rounded-number">6.6</span> after updating the status of the place-order, you can notify your customer by sending the email or SMS or whatever method about the status of the order.</simpara>
</listitem>
<listitem>
<simpara><span class="rounded-number">7</span> SEC executes the <emphasis role="strong">[Command] DeliveryExecutor</emphasis> that you provided. <span class="rounded-number">7.1</span> due to the executing the process method by the SEC, the <emphasis role="strong">ExternalDeliveryService&#8217;s</emphasis> <emphasis role="strong">addToDelivery()</emphasis> method will be invoked. <span class="rounded-number">7.2</span> the <emphasis role="strong">ExternalDeliveryService</emphasis> will call the <emphasis role="strong">delivery-service</emphasis> and make a request to add-to-delivery process. <span class="rounded-number">7.3</span> after successfully making the request, SEC will store the state of the aggregator. <span class="rounded-number">7.4</span> after saving the state in the event-store, SEC will execute the <emphasis role="strong">onEachProcessPerformed</emphasis> method of the handler class that you provided. <span class="rounded-number">7.5</span> then you can put your execution here to update the status of the place-order transaction. as the diagram, we have executed <emphasis role="strong">updateCustomerOrderStatus()</emphasis> method of <emphasis role="strong">InternalOrderService</emphasis> to update the status. <span class="rounded-number">7.6</span> after updating the status of the place-order, you can notify your customer by sending the email or SMS or whatever method about the status of the order.</simpara>
</listitem>
<listitem>
<simpara><span class="rounded-number">8</span> as the final step the SEC will invoke the <emphasis role="strong">onTransactionCompleted</emphasis> method of the handler. <span class="rounded-number">8.1</span> you can update the place-order status as the final state as <emphasis role="strong">success</emphasis>. <span class="rounded-number">8.2</span> after updating the place-order status, you can notify it to the customer.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="revert_success_transaction_scenario">
<title><inlinemediaobject role="yellow">
<imageobject>
<imagedata fileref="./images/icons/circle.png"/>
</imageobject>
<textobject><phrase>circle</phrase></textobject>
</inlinemediaobject> Compensation Success</title>
<simpara>here, the SEC hasn&#8217;t successfully executed all the executors. an error occurred while after some processing. therefore, the transaction has a compensation/revert executions.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="resources/img/Architecture-Stacksaga-revert-success-transaction-scenario.drawio.svg" contentdepth="300"/>
</imageobject>
<textobject><phrase>Compensation/Revert success transaction scenario</phrase></textobject>
</mediaobject>
</informalfigure>
<itemizedlist>
<listitem>
<simpara><span class="rounded-number">1</span> as the first step the users make the request and the <emphasis role="strong">OrderController</emphasis> catch the request.</simpara>
</listitem>
<listitem>
<simpara><span class="rounded-number">2</span> after having the request, initialize the place order aggregator and set the start executor into the StackSaga.
(In this time you have the transaction uid which is created by framework.
The <emphasis role="strong">transaction uid</emphasis> is the unique id for identifying each transaction.
You can get it from your created <emphasis role="strong">Aggregator</emphasis> object.
)</simpara>
</listitem>
<listitem>
<simpara><span class="rounded-number">3</span> now the execution processes are handled by the SEC.
Before invoking the executor that you provided as the <emphasis role="strong">start-executor</emphasis> SEC saves the initial state of the aggregator in the <emphasis role="strong">event-tore</emphasis>.</simpara>
</listitem>
<listitem>
<simpara><span class="rounded-number">4</span> SEC executes the start-executor<emphasis role="strong"> ([Command] CreateOrderExecutor)</emphasis> that you provided. <span class="rounded-number">4.1</span> due to the executing the process method by the SEC, the <emphasis role="strong">InternalOrderService&#8217;s</emphasis> <emphasis role="strong">createOrder()</emphasis> method will be invoked. <span class="rounded-number">4.2</span> after successfully invoking the method, SEC will store the state of the aggregator. <span class="rounded-number">4.3</span> after saving the state in the event-store, SEC will execute the <emphasis role="strong">onEachProcessPerformed</emphasis> method of the handler class that you provided. <span class="rounded-number">4.4</span> then you can put your execution here to update the status of the place-order transaction. as the diagram, we have executed <emphasis role="strong">updateCustomerOrderStatus()</emphasis> method of <emphasis role="strong">InternalOrderService</emphasis> to update the status. <span class="rounded-number">4.5</span> after updating the status of the place-order, you can notify your customer by sending the email or SMS or whatever method about the status of the order.</simpara>
</listitem>
<listitem>
<simpara><span class="rounded-number">5</span> SEC executes the 2nd executor that you provided from the 1st executor. <span class="rounded-number">5.1</span> due to the executing the <emphasis role="strong">doProcess</emphasis> method of the <emphasis role="strong">[Query] UserExecutor</emphasis> by the SEC, the <emphasis role="strong">ExternalUserStatusService&#8217;s</emphasis> <emphasis role="strong">checkUser()</emphasis> method will be invoked. <span class="rounded-number">5.2</span> the <emphasis role="strong">ExternalUserStatusService</emphasis> will call the <emphasis role="strong">user-service</emphasis> and make a request. <span class="rounded-number">5.3</span> after successfully invoking the request, SEC will store the state of the aggregator of 2nd process. <span class="rounded-number">5.4</span> after saving the state in the event-store, SEC will execute the <emphasis role="strong">onEachProcessPerformed</emphasis> method of the handler class that you provided.</simpara>
<simpara><emphasis role="marked">Due to this executor is a query executor, there is no status update process have been executed here.</emphasis></simpara>
</listitem>
<listitem>
<simpara><span class="rounded-number">6</span> SEC executes the <emphasis role="strong">[Command] PaymentExecutor</emphasis> executor that you provided. <span class="rounded-number">6.1</span> due to the executing the process method by the SEC, the <emphasis role="strong">ExternalPaymentService&#8217;s</emphasis> <emphasis role="strong">makePayment()</emphasis> method will be invoked. <span class="rounded-number">6.2</span> the <emphasis role="strong">ExternalPaymentService</emphasis> will call the <emphasis role="strong">payment-service</emphasis> and make a request to make-payment process. at this time, the request failed due to an exception.</simpara>
</listitem>
<listitem>
<simpara><span class="rounded-number">7</span> the SEC will invoke <emphasis role="strong">onProcessException</emphasis> method of the handler class that you provided. there you can get notified about the <emphasis role="strong">process failure.</emphasis> the transaction can&#8217;t be executed forward anymore, the compensation process will start from this point.</simpara>
<simpara>**if you want to update the order status or update the customer, you can invoke your code here. in this example, it hasn&#8217;t been implemented.</simpara>
</listitem>
<listitem>
<simpara><span class="rounded-number">8</span> due to the final successful executed <emphasis role="strong">OrderExecutor</emphasis> (There is no compensation because the UserExecutor is a query executor.) SEC invokes the <emphasis role="strong">doRevert</emphasis> method of the <emphasis role="strong">OrderExecutor</emphasis>. <span class="rounded-number">8.1</span> due to the executing of the <emphasis role="strong">doRevert</emphasis> method, <emphasis role="strong">createOrderRevert</emphasis> method will be invoked and do the revert process of the make-payment. <span class="rounded-number">8.2</span> in the compensation process if you want to store some data regarding the revert process, you can store them into the [hint-store] the framework provides. that stored data is saved at this step. <span class="rounded-number">8.4</span> after invoking successfully the revert, the SEC will invoke <emphasis role="strong">onEachRevertPerformed</emphasis> method regarding the revert process. <span class="rounded-number">8.4</span> the customer will be notified about the revert process. (if you want to update the order status, you can invoke your code here as well. that part hasn&#8217;t been implemented in this example.)</simpara>
</listitem>
<listitem>
<simpara><span class="rounded-number">9</span> StackSaga state-machine knows that the compensation is done. therefore, SEC invokes the <emphasis role="strong">onTransactionCompleted</emphasis> method as <emphasis role="strong">REVERT_SUCCESS</emphasis>. <span class="rounded-number">9.1</span> you can update the status of the place-order regarding the revert was processed. <span class="rounded-number">9.2</span> after that the customer will be notified about the revert success process of their order.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>To keep the overall state of the transaction eventually consistent, the revert processes (compensation processes) can be retryable.
Because all the compensations must be invoked.
To have knowledge about how retry works of revert-processes in StackSaga, please refer to <link xl:href="https://mafei-dev.github.io/stacksaga-doc/architecture/1.0/topics/retryable-exception-vs-non-retryable-exception.html#how-retry-works-in-the-revert-process">this</link>.</simpara>
</note>
</section>
<section xml:id="revert_failed_transaction_scenario">
<title><inlinemediaobject role="red">
<imageobject>
<imagedata fileref="./images/icons/circle.png"/>
</imageobject>
<textobject><phrase>circle</phrase></textobject>
</inlinemediaobject> Compensation Failed</title>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="resources/img/Architecture-Stacksaga-evert-failed-transaction-scenario.drawio.svg" contentdepth="300"/>
</imageobject>
<textobject><phrase>Compensation/Revert failed transaction scenario</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
</section>
</chapter>
<chapter xml:id="stacksaga_admin_index">
<title>StackSaga Admin</title>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="./images/icons/tachometer.png"/>
</imageobject>
<textobject><phrase>tachometer</phrase></textobject>
</inlinemediaobject></simpara>
<simpara>StackSaga Admin Server is the monitoring dashboard of the StackSaga framework.</simpara>
<note>
<simpara>Event though StackSaga framework can be run without the admin-server, it is recommended to connect the admin-server with other StackSaga clients.</simpara>
</note>
<table frame="all" rowsep="1" colsep="1">
<title>ROLES</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">ROLE</entry>
<entry align="left" valign="top">Permissions</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>SUPER_ADMIN</simpara></entry>
<entry align="left" valign="top"><simpara>- Manage Admin Users</simpara></entry>
<entry align="left" valign="top"><simpara>USER_TYPE</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ADMIN</simpara></entry>
<entry align="left" valign="top"><simpara>- Manage OPERATOR_ROLE<?asciidoc-br?>
- Manage GATEWAY_ROLE<?asciidoc-br?>
- Manage SERVICE_ROLE</simpara></entry>
<entry align="left" valign="top"><simpara>USER_TYPE</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OPERATOR_ROLE</simpara></entry>
<entry align="left" valign="top"><simpara>- Monitor the transactions.</simpara></entry>
<entry align="left" valign="top"><simpara>USER_TYPE</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GATEWAY_ROLE</simpara></entry>
<entry align="left" valign="top"><simpara>- Connect Gateway</simpara></entry>
<entry align="left" valign="top"><simpara>APPLICATION_TYPE</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SERVICE_ROLE</simpara></entry>
<entry align="left" valign="top"><simpara>- Connect Service</simpara></entry>
<entry align="left" valign="top"><simpara>APPLICATION_TYPE</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<note>
<simpara>By default, super admin has an operator role as well.</simpara>
</note>
<table frame="all" rowsep="1" colsep="1">
<title>Admin Service Specification</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Context</entry>
<entry align="left" valign="top">Technology</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Backend</simpara></entry>
<entry align="left" valign="top"><simpara>Spring boot with reactive</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Frontend</simpara></entry>
<entry align="left" valign="top"><simpara>Angular</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Database</simpara></entry>
<entry align="left" valign="top"><simpara>Mysql with the help of spring R2DBC and liquibase</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Security</simpara></entry>
<entry align="left" valign="top"><simpara>JWT for <emphasis role="strong">Front Users</emphasis>, and  Basic authentication for <emphasis role="strong">Gateway Users</emphasis> and <emphasis role="strong">Service Users</emphasis>.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<section xml:id="setup_the_service">
<title>Set up The Service</title>
<simpara>StackSaga Admin Server can be started in multiple ways.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="stacksaga_admin_docker_image">Using Docker Image</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="stacksaga_admin_jar">Using Jar</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="stacksaga_admin_source">Using Source</link></simpara>
</listitem>
</orderedlist>
<section xml:id="stacksaga_admin_docker_image">
<title>StackSaga Admin Docker Image</title>
<simpara>If docker is running on your computer, you can build a container and run StackSaga server (admin) by using the docker StackSaga server (admin) docker image.<?asciidoc-br?></simpara>
<simpara>You can choose the StackSaga server wit specific database that you want. <link xl:href="https://hub.docker.com/u/stacksaga">See all images on docker hub.</link></simpara>
<simpara>For instance, if you prefer to use mysql StackSaga server, you can run the code to pull the image.</simpara>
<programlisting language="shell" linenumbering="unnumbered">docker pull stacksaga/stacksaga_admin_mysqll:latest</programlisting>
<simpara>After pulling the image, you can create an image, and then you have to provide the following Environment variables.</simpara>
<programlisting language="shell" linenumbering="unnumbered">docker run -d \
-p 4444:4444 \
-e DB_URL=jdbc:mysql://localhost:3306/stacksaga_admin_db?createDatabaseIfNotExist=true  \
-e DB_R2DBC_URL=r2dbc:mysql://localhost:3306/stacksaga_admin_db \
-e DB_USERNAME=root \
-e DB_PASSWORD=*** \
-e DROP_FIRST_DB=your-config \
-e SECRET=*** \
-e TOKEN_EXPIRATION_TIME=60000 \
--name stacksaga-admin-server \
stacksaga/stacksaga_admin_mysql:1.0.0</programlisting>
<simpara>OR, if you prefer doing the deal with docker compose, here is the basic code snippet that you want tin run your own container.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">version: '3'
services:
  stacksaga_admin_mysql:
    container_name: stacksaga_admin_mysql
    image: "stacksaga/stacksaga_admin_mysql:1.0.0"
    ports:
      - "4444:4444"
    restart: always
    environment:
      - DB_URL=jdbc:mysql://host.docker.internal:3306/stacksaga_admin_db?createDatabaseIfNotExist=true
      - DB_R2DBC_URL=r2dbc:mysql://host.docker.internal:3306/stacksaga_admin_db
      - DB_USERNAME=root
      - DB_PASSWORD=mafei
      - DROP_FIRST_DB=true
      - SECRET=c403ba24-ea8f-4285-977a-a5b6361b427a
      - TOKEN_EXPIRATION_TIME=600000</programlisting>
<simpara>to run the docker-compose file, go the file directory and run this code.</simpara>
<programlisting language="shell" linenumbering="unnumbered">docker compose up</programlisting>
</section>
<section xml:id="stacksaga_admin_jar">
<title>StackSaga Admin Jar</title>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="./images/icons/download.png"/>
</imageobject>
<textobject><phrase>download</phrase></textobject>
</inlinemediaobject>
Here is the standalone version of StackSaga admin server.
You can download the <emphasis role="strong">stack-saga-admin-server.zip</emphasis>.</simpara>
<simpara><emphasis role="strong">Downloads</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://mega.nz/folder/w8lRXYyI#q5CFtVrNTCJtqYUuDzPPkA">StackSaga Admin Server - MySQL</link></simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">Minimum Requirements</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>Java java 8 or upper</simpara>
</listitem>
<listitem>
<simpara>Selected Database</simpara>
</listitem>
</itemizedlist>
<simpara>After unzipping the file, you will see the jar file.
To run the jar file, run the <literal>START.sh</literal> file or the following code below.
Before run the jar, make sure to config your custom configuration in the <literal>application-proud.properties</literal> file.</simpara>
<simpara><emphasis role="strong">&gt; Run on the console</emphasis></simpara>
<programlisting language="shell" linenumbering="unnumbered">java -jar stack-saga-admin-1.0-SNAPSHOT.jar --spring.config.location=file:application-proud.properties</programlisting>
<note>
<simpara>As you know in Spring application the default configuration file is <literal>application.properties</literal>.
But your custom configurations should be in the <literal>application-proud.properties</literal> file.
Because all the necessary configurations have been set in the default configuration file.</simpara>
</note>
<simpara>All the required configurations are as follows:</simpara>
<programlisting language="properties" linenumbering="unnumbered">#security
stacksaga.admin.security.expiration-time=60000
stacksaga.admin.security.secret=********************************
#r2dbc
spring.r2dbc.url=r2dbc:mysql://localhost:3306
spring.r2dbc.username=username
spring.r2dbc.password=*********
#liquibase
spring.liquibase.url=jdbc:mysql://localhost:3306/${stacksaga.admin.database-name}?createDatabaseIfNotExist=true}
spring.liquibase.user=${spring.r2dbc.username}
spring.liquibase.password=${spring.r2dbc.password}
#logging
logging.level.root=info</programlisting>
<note>
<simpara>For managing Database versions, <link xl:href="https://www.liquibase.org"><literal>liquibase</literal></link> has been used for StackSaga Admin server.
And also for accessing the database in reactive mode,
<link xl:href="https://spring.io/projects/spring-data-r2dbc"><literal>R2DBC</literal></link> has been used.
Due to reactive has no any framework for managing database versions, StackSaga team has used both dependencies together.
That&#8217;s two database configurations should be configured here for the same database.</simpara>
</note>
<tip>
<simpara>If you want to add more configurations regarding the database and many more, please follow the spring reference documentation.
Because all other configurations will be applied according to the spring boot framework.</simpara>
</tip>
</section>
<section xml:id="stacksaga_admin_source">
<title>StackSaga Admin Source Code</title>
<simpara>If you want to build the StackSaga Admin Server standalone jar from scratch, you can use the <emphasis role="strong">stack-saga-admin</emphasis> repository on <link xl:href="https://github.com/stacksaga/stack-saga-admin">GitHub</link>.</simpara>
</section>
</section>
<section xml:id="dashboard_initialize">
<title>Initialize Dashboard</title>
<simpara><emphasis role="strong">Step-1.</emphasis><?asciidoc-br?>
After successfully running the server, Initially you can see <emphasis role="strong">Admin-initialization-key</emphasis> in the console like below.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="resources/img/Admin-initialization-key-StackSaga.png" contentdepth="300"/>
</imageobject>
<textobject><phrase>admin initialization key In StackSaga</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><emphasis role="strong">Step-2.</emphasis><?asciidoc-br?>
Copy the key and go to the admin dashboard <literal>http://localhost:4444</literal> and enter the code click the button <emphasis role="strong"><literal>Initialize the server</literal></emphasis></simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="resources/img/Admin-initialization-page-StackSaga.png" contentdepth="300"/>
</imageobject>
<textobject><phrase>admin initialization page StackSaga</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><emphasis role="strong">Step-3.</emphasis><?asciidoc-br?>
Enter the super admin details create a new <emphasis role="strong">Super-Admin</emphasis>.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="resources/img/Stacksaga-Admin-Server-Super-Admin-Create-page.png" contentdepth="300"/>
</imageobject>
<textobject><phrase>Super Admin Create - StackSaga</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><emphasis role="strong">Step-4.</emphasis><?asciidoc-br?>
Login with the credentials that provided.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="resources/img/Stacksaga-Admin-Server-Admin-login-page.png" contentdepth="300"/>
</imageobject>
<textobject><phrase>Admin login page - StackSaga</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><emphasis role="strong">Step-5.</emphasis><?asciidoc-br?>
<emphasis>Congratulations!</emphasis> now you have successfully finished the initialization process.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="resources/img/Stacksaga-Admin-Server-Super-Admin-page.png" contentdepth="300"/>
</imageobject>
<textobject><phrase>Admin Dashboard - StackSaga</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="create_api_gateway_user">
<title>Create API Gateway User</title>
<simpara>To communicate individual services with the admin, StackSaga Connect should be used and therefore, to protect the <emphasis role="strong"><literal>/stacksaga</literal></emphasis> endpoints, StackSaga shield also should be used.
To use the StackSaga shield with the api gateway, we have to create a <emphasis role="strong"><literal>ROLE_GATEWAY</literal></emphasis> user and get the credentials.
Let&#8217;s go to the StackSaga Admin dashboard and create a new user for a new api-gateway step by step.<?asciidoc-br?>
Read <link linkend="stacksaga_high_level">StackSaga architecture in high-level</link> page to get the idea how to behave the ecosystem.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Go to the <emphasis role="strong">user&#8217;s</emphasis> page and select the <emphasis role="strong">Registration</emphasis> tab to register the new api gateway user.<?asciidoc-br?></simpara>
</listitem>
</orderedlist>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="resources/img/create-ROLE-GATEWAY-step-1.png" contentdepth="300"/>
</imageobject>
<textobject><phrase>StackSaga High-level architecture</phrase></textobject>
</mediaobject>
</informalfigure>
<orderedlist numeration="arabic">
<listitem>
<simpara>Before adding the gateway user, we have to create a new api-gateway (because in the StackSaga system, one api-gateway-can have multiple gateway-users.)<?asciidoc-br?></simpara>
</listitem>
</orderedlist>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="resources/img/create-ROLE-GATEWAY-step-2.png" contentdepth="300"/>
</imageobject>
<textobject><phrase>StackSaga High-level architecture</phrase></textobject>
</mediaobject>
</informalfigure>
<orderedlist numeration="arabic">
<listitem>
<simpara>After entering the user data, you will have a generated password by the StackSaga admin.
Save the username and the password in a secret file.
It is the credential that we want use for the shield congregation properties.<?asciidoc-br?></simpara>
</listitem>
</orderedlist>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="resources/img/create-ROLE-GATEWAY-step-3.png" contentdepth="300"/>
</imageobject>
<textobject><phrase>StackSaga High-level architecture</phrase></textobject>
</mediaobject>
</informalfigure>
<orderedlist numeration="arabic">
<listitem>
<simpara>you can see the new user in the list.<?asciidoc-br?></simpara>
</listitem>
</orderedlist>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="resources/img/create-ROLE-GATEWAY-step-4.png" contentdepth="300"/>
</imageobject>
<textobject><phrase>StackSaga High-level architecture</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="create_service_user">
<title>Create Service User</title>

</section>
<section xml:id="create_operator_user">
<title>Create Operator User</title>

</section>
</chapter>
<chapter xml:id="stacksaga_core_index">
<title>StackSaga Starter Core</title>
<simpara>StackSaga core dependency consists of many modules and topics like
<link linkend="creating_aggregator_class">Aggregator</link>, <link linkend="saga_executors">Executors</link>, and <link linkend="saga_revert_hint_store">RevertHintStore</link> many more.
You can go through each topic to have comprehensive knowledge.</simpara>
<simpara>To use the <literal>StackSaga core</literal> dependency in your application you need to add the dependency in your application.</simpara>
<itemizedlist>
<listitem>
<simpara>Maven Dependency</simpara>
</listitem>
</itemizedlist>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
    &lt;groupId&gt;org.stacksaga&lt;/groupId&gt;
    &lt;artifactId&gt;stacksaga-spring-boot-starter-core&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;</programlisting>
<simpara>For your convenience, all the configuration details have been mentioned here.</simpara>
<section xml:id="creating_aggregator_class">
<title>Creating Aggregator Class</title>
<simpara>The aggregator<superscript><link linkend="aggregator_architecture">ref</link></superscript>  class does represent your business domain, and it is the container for carrying out the data for the executors.
In side of the aggregator class, you should provide all the data regarding your entire transaction.</simpara>
<simpara>example: Just think you are will be to make a transaction for place and order by using StackSaga. then you have to create an Aggregator class to put the data that you want to while the whole process. you can create an Aggregator class called <literal>PlaceOrderAggregator</literal> and provide all the data that you want like <emphasis>username, orderId, transactionId</emphasis> etc&#8230;&#8203; and also you might want to add complex data structure inside that aggregate class like <emphasis>list of items</emphasis> regarding the items that the customer&#8217;s order. then you have to create a java pojo as well. as a best practice, the framework suggests you to create all related pojo classes in the same package of the Aggregator class or as the inner classes of the Aggregator class.</simpara>
<simpara>To be an aggregator in StackSaga, Mainly, The aggregator class should be extended from <literal>org.stacksaga.SagaAggregate</literal> class and also the aggregator class should be annotated with <literal>org.stacksaga.core.annotation.Aggregator</literal>.</simpara>
<warning>
<simpara>All the classes (main aggregator class and other classes that are used inside it) that are used for the SagaAggregator should be implemented by the <literal>java.io.Serializable</literal> class.
By default, The main aggregator class is Serializable due to the fact that it is implemented from the <literal>SagaAggregate</literal> class. <link linkend="complex_aggrgator">See complex object implementation</link></simpara>
</warning>
<simpara>Let&#8217;s see how it is created in StackSaga project.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Aggregator(<co xml:id="CO1-1"/>
        version = @AggregatorVersion(major = 1, minor = 0, patch = 1), <co xml:id="CO1-2"/>
        idPrefix = "po", <co xml:id="CO1-3"/>
        name = "PlaceOrderAggregator", <co xml:id="CO1-4"/>
        sagaSerializable = PlaceOrderAggregatorSample.class <co xml:id="CO1-5"/>
)
@Getter <co xml:id="CO1-6"/>
@Setter <co xml:id="CO1-7"/>
public class PlaceOrderAggregator extends SagaAggregate  { <co xml:id="CO1-8"/>

    <co xml:id="CO1-9"/>
    public PlaceOrderAggregator() {
        super(PlaceOrderAggregator.class);
    }

    private String orderId;
    private String username;
    private int isActive;
}</programlisting>
<calloutlist>
<callout arearefs="CO1-1">
<para>The aggregator class should be annotated with <literal>org.stacksaga.core.annotation.Aggregator</literal>.</para>
</callout>
<callout arearefs="CO1-2">
<para><emphasis role="strong">version</emphasis> will be used for the identification of the aggregator versioning. it is helpful for the <emphasis role="strong">event-upper-casting</emphasis> and <emphasis role="strong">event-down-casting</emphasis>. <literal>org.stacksaga.core.annotation.AggregatorVersion</literal> annotation help you to provide the version of the aggregator.</para>
</callout>
<callout arearefs="CO1-3">
<para><emphasis role="strong">idPrefix</emphasis> will be used as the prefix of the transaction id. you can give a prefix according to the aggregator name.
The maximum length of the prefix is 4 characters.</para>
</callout>
<callout arearefs="CO1-4">
<para><emphasis role="strong">name</emphasis> The name of the aggregator. this is used for identification of the aggregator by the name.</para>
</callout>
<callout arearefs="CO1-5">
<para><emphasis role="strong">sagaSerializable</emphasis> is used for pre-serialization of the samples of the aggregator. <link linkend="saga_serializable">see the implementation</link></para>
</callout>
<callout arearefs="CO1-6">
<para><emphasis role="strong">Getter</emphasis> you can create getters as usual for the aggregator.</para>
</callout>
<callout arearefs="CO1-7">
<para><emphasis role="strong">Setter</emphasis> you can create setters as usual for the aggregator.</para>
</callout>
<callout arearefs="CO1-8">
<para>The aggregator class should be implemented from the <literal>org.stacksaga.SagaAggregate</literal> class.
It provides the shep of aggregator in the framework.</para>
</callout>
<callout arearefs="CO1-9">
<para>The aggregator class should have the default constructor and also the <emphasis role="strong">super()</emphasis> method should be called by passing the same aggregator class.</para>
</callout>
</calloutlist>
<warning>
<simpara>The name of the aggregator should be the same forever.
Because, all the event-store data is mapped with the aggregator name.</simpara>
</warning>
<tip>
<simpara>Due to the fact that the aggregator name is configured by an attribute, you can change the package of the aggregator class anytime.</simpara>
</tip>
<note>
<simpara>In StackSaga, The aggregator is not a spring bean at all.
Therefore, it is not necessary to have inside the <emphasis role="strong">component scan</emphasis> area.</simpara>
</note>
</section>
<section xml:id="saga_serializable">
<title>Creating SagaSerializable Class for Aggregator</title>
<simpara>The <literal>SagaSerializable</literal> class provides you a method called <literal>&lt;T&gt; getSamples()</literal> to provide the sample array of objects of your real Aggregator. for each aggregator class that you made should have a separate implementation of <literal>SagaSerializable</literal> for validating the sample object before the application is started. that process ensures that your aggregator object will not face a serialization error while the transactions are being processed in the production.</simpara>
<simpara>you can see a sample SagaSerializable <literal>(PlaceOrderAggregatorSample.class)</literal> implementation of the PlaceOrderAggregator.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class PlaceOrderAggregatorSample implements SagaSerializable&lt;PlaceOrderAggregator&gt; { <co xml:id="CO2-1"/>
    @Override
    public PlaceOrderAggregator[] getSamples() {
        //samples objects for the PlaceOrderAggregator

        //sample-1
        PlaceOrderAggregator aggregator1 = new PlaceOrderAggregator();
        aggregator1.setOrderId(UUID.randomUUID().toString());

        //sample-1
        PlaceOrderAggregator aggregator2 = new PlaceOrderAggregator();
        aggregator2.setOrderId(UUID.randomUUID().toString());
        aggregator2.setUsername("mafei");

        <co xml:id="CO2-2"/>
        return new PlaceOrderAggregator[]{
                aggregator1,
                aggregator2,
        };
    }
}</programlisting>
<calloutlist>
<callout arearefs="CO2-1">
<para>Implement your custom <literal>PlaceOrderAggregatorSample</literal> from the <literal>SagaSerializable&lt;T&gt;</literal>.
The generic type should be the aggregator that you wish to check the sample object.
According to the example, the Type is <literal>PlaceOrderAggregator</literal>.
Then you will have a method for providing the sample objects for that given type.</para>
</callout>
<callout arearefs="CO2-2">
<para>Rerun your initialized sample objects by creating a new array for the validation process.</para>
</callout>
</calloutlist>
<warning>
<simpara>Make sure to keep the default constructor for each SagaSerializable implementation.</simpara>
</warning>
</section>
<section xml:id="aggregator_mapper_implementation">
<title>Custom Aggregator Mapper</title>
<simpara>You can decide your custom configurations of the objectMapper for your target <link linkend="creating_aggregator_class">Aggregator</link>.
By default, the system will use an <link xl:href="https://fasterxml.github.io/jackson-databind/javadoc/2.7/com/fasterxml/jackson/databind/ObjectMapper.html"><literal>ObjectMapper</literal></link>
that the framework provides for the aggregator serialization and deserialization.
But if you want to customize the objectMapper for your target aggregator, you can create and provide a custom objectMapper object for the target aggregator by using <literal>SagaAggregatorMapperProvider</literal> implementation.
Then The framework will use the custom Aggregator Mapper that you provided to the target aggregator.</simpara>
<note>
<simpara>The class should be a Spring bean (Annotate with <literal>@Component</literal>).</simpara>
</note>
<simpara>Here you can see a custom implementation of the <literal>AggregatorMapper</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Component <co xml:id="CO3-1"/>
public class PlaceOrderAggregatorJsonMapper implements SagaAggregatorMapperProvider  {<co xml:id="CO3-2"/>

    private final ObjectMapper objectMapper;

    public PlaceOrderAggregatorJsonMapper() {
        this.objectMapper = new ObjectMapper(); <co xml:id="CO3-3"/>
        //your custom object mapper configurations
        ...
    }

    <co xml:id="CO3-4"/>
    @Override
    public SagaAggregatorMapper getSagaAggregatorMapper() {
        return SagaAggregatorMapper.Builder.build(
                this.objectMapper
        );<co xml:id="CO3-5"/>
    }
}</programlisting>
<calloutlist>
<callout arearefs="CO3-1">
<para><emphasis role="strong">@Component</emphasis>: Mark your custom object mapper implementation as a Spring bean.</para>
</callout>
<callout arearefs="CO3-2">
<para><emphasis role="strong">SagaAggregatorMapperProvider</emphasis>: Implement by the <literal>SagaAggregatorMapperProvider</literal> interface.</para>
</callout>
<callout arearefs="CO3-3">
<para>Initialize and set your custom configurations for the <literal>objectMapper</literal> object that you provide for the target aggregator.</para>
</callout>
<callout arearefs="CO3-4">
<para>Override the method for providing the <literal>SagaAggregatorMapper</literal> object.</para>
</callout>
<callout arearefs="CO3-5">
<para><emphasis role="strong">SagaAggregatorMapper.Builder</emphasis>: The builder class provides the methods for building <literal>SagaAggregatorMapper</literal> object.
you can build <literal>SagaAggregatorMapper</literal> object by adding your custom configured objectMapper object and return it back.</para>
</callout>
</calloutlist>
<note>
<simpara>The <literal>SagaAggregatorMapper.Builder</literal> class can have several build methods with several mapper types other than the <literal>ObjectMapper</literal>.
Currently, StackSaga framework only supports <literal>ObjectMapper</literal>.</simpara>
</note>
<simpara>You can provide your custom object <literal>SagaAggregatorMapperProvider</literal> class to the target Aggregator like below.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Aggregator(
        version = @AggregatorVersion(major = 1, minor = 0, patch = 1),
        idPrefix = "po",
        name = "PlaceOrderAggregator",
        sagaSerializable = PlaceOrderAggregatorSample.class,
        mapper = PlaceOrderAggregatorJsonMapper.class <co xml:id="CO4-1"/>
)
@Getter
@Setter
public class PlaceOrderAggregator extends SagaAggregate {

    public PlaceOrderAggregator() {
        super(PlaceOrderAggregator.class);
    }
    ...
}</programlisting>
<calloutlist>
<callout arearefs="CO4-1">
<para><emphasis role="strong">mapper</emphasis>: provide your custom aggregator mapper provider class.</para>
</callout>
</calloutlist>
<simpara><?asciidoc-hr?></simpara>
</section>
<section xml:id="complex_aggrgator">
<title>Full Aggregate implementation.</title>
<programlisting language="java" linenumbering="unnumbered">//Aggregtor Classs
@Aggregator(
        version = @AggregatorVersion(major = 1, minor = 0, patch = 1),
        idPrefix = "po",
        name = "PlaceOrderAggregator",
        sagaSerializable = PlaceOrderAggregatorSample.class
)
@Getter
@Setter
public class PlaceOrderAggregator extends SagaAggregate {

    public PlaceOrderAggregator() {
        super(PlaceOrderAggregator.class);
    }

    private String orderId;
    private String username;
    private int isActive;
    private List&lt;ItemDetail&gt; itemDetails = new ArrayList&lt;&gt;();
}

//Pojo Class for Item Details
@Getter
@Setter
@Builder
class ItemDetail implements Serializable { <co xml:id="CO5-1"/>
    private String itemName;
    private int qty;
    private double price;
}

//Saga Serializable Class
class PlaceOrderAggregatorSample implements SagaSerializable&lt;PlaceOrderAggregator&gt; {
    @Override
    public PlaceOrderAggregator[] getSamples() {
        //sample-1
        PlaceOrderAggregator aggregator1 = new PlaceOrderAggregator();
        aggregator1.setOrderId(UUID.randomUUID().toString());
        //sample-1
        PlaceOrderAggregator aggregator2 = new PlaceOrderAggregator();
        aggregator2.setOrderId(UUID.randomUUID().toString());
        aggregator2.setUsername("mafei");
        //sample-3
        PlaceOrderAggregator aggregator3 = new PlaceOrderAggregator();
        aggregator3.getItemDetails().add(
                ItemDetail
                        .builder()
                        .itemName("Item-01")
                        .price(10.50)
                        .qty(2)
                        .build()
        );

        return new PlaceOrderAggregator[]{
                aggregator1,
                aggregator2,
                aggregator3,
        };
    }
}</programlisting>
<calloutlist>
<callout arearefs="CO5-1">
<para>It is necessary to be implemented by the  <literal>Serializable</literal>.</para>
</callout>
</calloutlist>
</section>
<section xml:id="saga_executors">
<title>Saga Executors.</title>
<simpara>According to the saga design pattern, sub processes (atomic executions) can have two executions called process execution and compensation execution.
And those executions you van create as the methods in your application anywhere.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><emphasis role="strong"><link linkend="query_executor">Query executors</link></emphasis>: If some atomic process has no compensation, that kind of process is used in a query executor.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong"><link linkend="command_executor">Command executors</link></emphasis>:
If some atomic process has a compensation (revert execution), that kind of process is used in a command executor.<?asciidoc-br?>
<emphasis role="strong">Revert executors</emphasis>: For the compensation process of the command executor it can be used other sub processes if you need.</simpara>
<orderedlist numeration="lowerroman">
<listitem>
<simpara><emphasis role="strong"><link linkend="revert_before_executor">Revert Before Executors</link></emphasis>: If you want to execute an atomic process before executing the main revert process, you can create a Revert-Before-Executor.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong"><link linkend="revert_after_executor">Revert After Executors</link></emphasis>: If you want to execute an atomic process after executing the main revert process, you can create a Revert-Before-Executor.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<section xml:id="query_executor">
<title>Query Executor.</title>
<simpara>You can create any number of your custom Query-Executors regarding the Aggregator.
Here you can see how you can create a Query-Executor for your <literal><link linkend="creating_aggregator_class">PlaceOrderAggregator</link></literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered"><co xml:id="CO6-1"/>
@SagaExecutor(
        executeFor = "user-service", <co xml:id="CO6-2"/>
        liveCheck = true, <co xml:id="CO6-3"/>
        value = "CheckUserExecutor" <co xml:id="CO6-4"/>
)
public class CheckUserExecutor implements QueryExecutor&lt;PlaceOrderAggregator&gt; { <co xml:id="CO6-5"/>

    <co xml:id="CO6-6"/>
    @Override
    public ProcessStepManager&lt;PlaceOrderAggregator&gt; doProcess(
            ProcessStack processStack,
            PlaceOrderAggregator aggregator,
            ProcessStepManagerUtil&lt;PlaceOrderAggregator&gt; stepManagerUtil
    ) throws RetryableExecutorException, NonRetryableExecutorException {
        //execute the service and check the conndtion.

        //return or throw <co xml:id="CO6-7"/>
    }
}</programlisting>
<calloutlist>
<callout arearefs="CO6-1">
<para><emphasis role="strong">@SagaExecutor</emphasis>: annotate your query executor with <literal>@org.stacksaga.annotation.SagaExecutor</literal> annotation.
The annotation provides the spring bean capabilities and also another metadata for the StackSaga framework.</para>
</callout>
<callout arearefs="CO6-2">
<para><emphasis role="strong">executeFor</emphasis>: The name of the service that particular executor is going to be connected. it can be a service name of another service. if the service is spring boot service, make sure to keep the application name as its. because it will be helpful for the retry process.</para>
</callout>
<callout arearefs="CO6-3">
<para><emphasis role="strong">liveCheck</emphasis>: When the retry process is executed, liveCheck is considered by the engine. if the target service is a spring boot service or registered service with the service registry, the availability is checked before executing the retry by the StackSaga engine.</para>
</callout>
<callout arearefs="CO6-4">
<para><emphasis role="strong">value</emphasis>: The bean name of the executor.
The executor is identified with this value by StackSaga engine. after configuring the bean name, it cannot be changed at all. if you want to the class package, it does not matter without changing the configured name.</para>
</callout>
<callout arearefs="CO6-5">
<para><emphasis role="strong">QueryExecutor&lt;T&gt;</emphasis> IF the executor is Query one, The executor should be implemented by <literal>org.stacksaga.executor.QueryExecutor&lt;T&gt;</literal>. <literal>T</literal> should be the target Aggregator class for the domain.</para>
</callout>
<callout arearefs="CO6-6">
<para>Override the <literal>doProcess()</literal>  method and put your execution code block that should be executed when the executor is executed by the StackSaga engine.</para>
</callout>
<callout arearefs="CO6-7">
<para>Finally, you can either return the next executor with the method that provides by the <literal>ProcessStepManager</literal>.</para>
</callout>
</calloutlist>
</section>
<section xml:id="command_executor">
<title>Command Executor.</title>
<programlisting language="java" linenumbering="unnumbered"><co xml:id="CO7-1"/>
@SagaExecutor(
        executeFor = "delivery-service", <co xml:id="CO7-2"/>
        liveCheck = true, <co xml:id="CO7-3"/>
        value = "DispatchOrderExecutor" <co xml:id="CO7-4"/>
)
public class DispatchOrderExecutor implements CommandExecutor&lt;PlaceOrderAggregator&gt; { <co xml:id="CO7-5"/>

    <co xml:id="CO7-6"/>
    @Override
    public ProcessStepManager&lt;PlaceOrderAggregator&gt; doProcess(
            ProcessStack processStack, <co xml:id="CO7-7"/>
            PlaceOrderAggregator aggregator, <co xml:id="CO7-8"/>
            ProcessStepManagerUtil&lt;PlaceOrderAggregator&gt; stepManager <co xml:id="CO7-9"/>
    ) throws RetryableExecutorException, NonRetryableExecutorException {
        //execute the service and check the conndtion.
        ...
        //return or throw <co xml:id="CO7-10"/>
    }

    @RevertBefore(startFrom = DispatchRevertNotifierExecutor.class)  <co xml:id="CO7-11"/>
    @RevertAfter(startFrom = DispatchRevertCompleteLogExecutor.class) <co xml:id="CO7-12"/>
    @Override
    public void doRevert(
            ProcessStack processStack,<co xml:id="CO7-13"/>
            NonRetryableExecutorException nonRetryableExecutorException,<co xml:id="CO7-14"/>
            PlaceOrderAggregator aggregator, <co xml:id="CO7-15"/>
            RevertHintStore revertHintStore <co xml:id="CO7-16"/>
    ) throws RetryableExecutorException {
        //call the atomic process that you want to as the compensation,
        ...
    }
}</programlisting>
<calloutlist>
<callout arearefs="CO7-1">
<para><emphasis role="strong">@SagaExecutor</emphasis>: annotate your query executor with <literal>@org.stacksaga.annotation.SagaExecutor</literal> annotation.
The annotation provides the spring bean capabilities and also another metadata for the StackSaga framework.</para>
</callout>
<callout arearefs="CO7-2">
<para><emphasis role="strong">executeFor</emphasis>: The name of the service that particular executor is going to be connected. it can be a service name of another service. if the service is spring boot service, make sure to keep the application name as its. because it will be helpful for the retry process.</para>
</callout>
<callout arearefs="CO7-3">
<para><emphasis role="strong">liveCheck</emphasis>: When the retry process is executed, liveCheck is considered by the engine. if the target service is a spring boot service or registered service with the service registry, the availability is checked before executing the retry by the StackSaga engine.</para>
</callout>
<callout arearefs="CO7-4">
<para><emphasis role="strong">value</emphasis>: The bean name of the executor.
The executor is identified with this value by StackSaga engine. after configuring the bean name, it cannot be changed at all. if you want to the class package, it does not matter without changing the configured name.</para>
</callout>
<callout arearefs="CO7-5">
<para><emphasis role="strong">CommandExecutor&lt;T&gt;</emphasis> IF the executor is command one, The executor should be implemented by <literal>org.stacksaga.executor.CommandExecutor&lt;T&gt;</literal>. <literal>T</literal> should be the target Aggregator class for the domain.</para>
</callout>
<callout arearefs="CO7-6">
<para>Override the <literal>doProcess()</literal>  method and put your execution code block that should be executed when the executor is executed by the StackSaga engine.</para>
</callout>
<callout arearefs="CO7-7">
<para><emphasis role="strong">ProcessStack</emphasis> Object provides all the executed execution until the process so far.
It will help for gen an idea about the execution history.
And also you can get the decision of the execution base on the execution history.</para>
</callout>
<callout arearefs="CO7-8">
<para><emphasis role="strong">PlaceOrderAggregator</emphasis>: The current aggregator state.</para>
</callout>
<callout arearefs="CO7-9">
<para><emphasis role="strong">ProcessStepManagerUtil&lt;T&gt;</emphasis>: This object provides the methods for giving the navigation to the engine regarding the next step. it can be another executor (command or query) or a process completion.</para>
</callout>
<callout arearefs="CO7-10">
<para>Inside the method scope, you can provide the execution that should be executed when the StackSaga engine executes.
And finally you can navigate to the next step by using the <literal>ProcessStepManagerUtil</literal> object.</para>
</callout>
<callout arearefs="CO7-11">
<para><emphasis role="strong">@RevertBefore</emphasis>: If the executor has any revert-before-executors, you can mention that executor class with <literal>@RevertBefore</literal> annotation.
According to the example, the revert before execution will be started from <link linkend="revert_before_executor">DispatchRevertNotifierExecutor</link>.</para>
</callout>
<callout arearefs="CO7-12">
<para><emphasis role="strong">@RevertAfter</emphasis>: If the executor has any revert-after-executors, you can mention that executor class with <literal>@RevertAfter</literal> annotation.
According to the example, the revert after execution will be started from <link linkend="revert_after_executor">DispatchRevertCompleteLogExecutor</link>.</para>
</callout>
<callout arearefs="CO7-13">
<para><emphasis role="strong">ProcessStack</emphasis> The final process stack that was when the final execution was executed.</para>
</callout>
<callout arearefs="CO7-14">
<para><emphasis role="strong">NonRetryableExecutorException</emphasis> The exception that caused the transition process stopping to forward.</para>
</callout>
<callout arearefs="CO7-15">
<para><emphasis role="strong">PlaceOrderAggregator</emphasis> The final aggregator state when the NonRetryableExecutorException is thrown.</para>
</callout>
<callout arearefs="CO7-16">
<para><emphasis role="strong">RevertHintStore</emphasis> If you want to add some data to the backward process, you can use the <literal>RevertHintStore</literal> to put the data.</para>
</callout>
</calloutlist>
<simpara><?asciidoc-hr?></simpara>
</section>
<section xml:id="revert_before_executor">
<title>Revert Before Executor.</title>
<programlisting language="java" linenumbering="unnumbered"><co xml:id="CO8-1"/>
@SagaExecutor(
        executeFor = "delivery-service",<co xml:id="CO8-2"/>
        liveCheck = true,<co xml:id="CO8-3"/>
        value = "DispatchRevertNotifierExecutor" <co xml:id="CO8-4"/>
)
public class DispatchRevertNotifierExecutor implements RevertBeforeExecutor&lt;PlaceOrderAggregator, DispatchOrderExecutor&gt; {<co xml:id="CO8-5"/>

    <co xml:id="CO8-6"/>
    @Override
    public RevertBeforeStepManager&lt;PlaceOrderAggregator, DispatchOrderExecutor&gt; doProcess(
            PlaceOrderAggregator aggregator,<co xml:id="CO8-7"/>
            ProcessStack previousProcessStack,<co xml:id="CO8-8"/>
            NonRetryableExecutorException processException,<co xml:id="CO8-9"/>
            RevertHintStore revertHintStore,<co xml:id="CO8-10"/>
            RevertBeforeStepManagerUtil&lt;PlaceOrderAggregator, DispatchOrderExecutor&gt; revertStepManagerUtil <co xml:id="CO8-11"/>
    ) throws RetryableExecutorException { <co xml:id="CO8-12"/>
        return revertStepManagerUtil.next(NextBeforExecutor.class); <co xml:id="CO8-13"/>
        //or
        return revertStepManagerUtil.complete(); <co xml:id="CO8-14"/>
    }
}</programlisting>
<calloutlist>
<callout arearefs="CO8-1">
<para><emphasis role="strong">@SagaExecutor</emphasis>: annotate your query executor with <literal>@org.stacksaga.annotation.SagaExecutor</literal> annotation.
The annotation provides the spring bean capabilities and also another metadata for the StackSaga framework.</para>
</callout>
<callout arearefs="CO8-2">
<para><emphasis role="strong">executeFor</emphasis>: The name of the service that particular executor is going to be connected. it can be a service name of another service. if the service is spring boot service, make sure to keep the application name as its. because it will be helpful for the retry process.</para>
</callout>
<callout arearefs="CO8-3">
<para><emphasis role="strong">liveCheck</emphasis>: When the retry process is executed, liveCheck is considered by the engine. if the target service is a spring boot service or registered service with the service registry, the availability is checked before executing the retry by the StackSaga engine.</para>
</callout>
<callout arearefs="CO8-4">
<para><emphasis role="strong">value</emphasis>: The bean name of the executor.
The executor is identified with this value by StackSaga engine. after configuring the bean name, it cannot be changed at all. if you want to the class package, it does not matter without changing the configured name.</para>
</callout>
<callout arearefs="CO8-5">
<para><emphasis role="strong">RevertBeforeExecutor&lt;A, E&gt;</emphasis>: The Revert Before Executor should be implemented from the <literal>RevertBeforeExecutor&lt;A,E&gt;</literal>.
Generic <emphasis role="strong">A</emphasis> is the aggregator.
Generic <emphasis role="strong">E</emphasis> is the <link linkend="command_executor">command-executor</link> of the given aggregator as the Generic <emphasis role="strong">A</emphasis>.</para>
</callout>
<callout arearefs="CO8-6">
<para>Override the <literal>doProcess()</literal> method that <literal>RevertBeforeExecutor</literal> provides.
That is the method is executed by the StackSaga engine.</para>
</callout>
<callout arearefs="CO8-7">
<para><emphasis role="strong">PlaceOrderAggregator</emphasis>: The final aggregator state when the process exception is thrown.</para>
</callout>
<callout arearefs="CO8-8">
<para><emphasis role="strong">ProcessStack</emphasis>: The final process stack when the process exception is thrown.</para>
</callout>
<callout arearefs="CO8-9">
<para><emphasis role="strong">NonRetryableExecutorException</emphasis>:The process-exception that was thrown by the last executor.</para>
</callout>
<callout arearefs="CO8-10">
<para><emphasis role="strong">RevertHintStore</emphasis> If you want to add some data to the backward process, you can use the <literal>RevertHintStore</literal> to put the data as container.</para>
</callout>
<callout arearefs="CO8-11">
<para><emphasis role="strong">RevertBeforeStepManagerUtil&lt;A, E&gt;</emphasis>: This object provides the methods for giving the navigation to the engine regarding the next step. it can be another revert-before-executor or a revert-before completion.</para>
</callout>
<callout arearefs="CO8-12">
<para><emphasis role="strong">RetryableExecutorException</emphasis>: If the revert before execution is failed due to a retryable exception, you can provide that by warping with <literal>RetryableExecutorException</literal>.</para>
</callout>
<callout arearefs="CO8-13">
<para><emphasis role="strong">next()</emphasis>: You can provide (only if you have) the next revert-before-executor with <literal>revertStepManagerUtil.next()</literal>.</para>
</callout>
<callout arearefs="CO8-14">
<para><emphasis role="strong">complete()</emphasis>: If you don&#8217;t have any revert-before-executor to be executed as next regarding the command-executor, you can return <literal>revertStepManagerUtil.complete()</literal>.</para>
</callout>
</calloutlist>
</section>
<section xml:id="revert_after_executor">
<title>Revert After Executor.</title>
<programlisting language="java" linenumbering="unnumbered"><co xml:id="CO9-1"/>
@SagaExecutor(
        executeFor = "delivery-service",<co xml:id="CO9-2"/>
        liveCheck = true,<co xml:id="CO9-3"/>
        value = "DispatchRevertNotifierExecutor" <co xml:id="CO9-4"/>
)
public class DispatchRevertCompleteLogExecutor implements RevertAfterExecutor&lt;PlaceOrderAggregator, DispatchOrderExecutor&gt; {<co xml:id="CO9-5"/>

    <co xml:id="CO9-6"/>
    @Override
    public RevertAfterStepManager&lt;PlaceOrderAggregator, DispatchOrderExecutor&gt; doProcess(
            PlaceOrderAggregator aggregator,<co xml:id="CO9-7"/>
            ProcessStack previousProcessStack,<co xml:id="CO9-8"/>
            NonRetryableExecutorException processException,<co xml:id="CO9-9"/>
            RevertHintStore revertHintStore,<co xml:id="CO9-10"/>
            RevertAfterStepManagerUtil&lt;PlaceOrderAggregator, DispatchOrderExecutor&gt; revertStepManagerUtil <co xml:id="CO9-11"/>
    ) throws RetryableExecutorException { <co xml:id="CO9-12"/>
        return revertStepManagerUtil.next(NextAfterExecutor.class); <co xml:id="CO9-13"/>
        //or
        return revertStepManagerUtil.complete(); <co xml:id="CO9-14"/>
    }
}</programlisting>
<calloutlist>
<callout arearefs="CO9-1">
<para><emphasis role="strong">@SagaExecutor</emphasis>: annotate your query executor with <literal>@org.stacksaga.annotation.SagaExecutor</literal> annotation.
The annotation provides the spring bean capabilities and also another metadata for the StackSaga framework.</para>
</callout>
<callout arearefs="CO9-2">
<para><emphasis role="strong">executeFor</emphasis>: The name of the service that particular executor is going to be connected. it can be a service name of another service. if the service is spring boot service, make sure to keep the application name as its. because it will be helpful for the retry process.</para>
</callout>
<callout arearefs="CO9-3">
<para><emphasis role="strong">liveCheck</emphasis>: When the retry process is executed, liveCheck is considered by the engine. if the target service is a spring boot service or registered service with the service registry, the availability is checked before executing the retry by the StackSaga engine.</para>
</callout>
<callout arearefs="CO9-4">
<para><emphasis role="strong">value</emphasis>: The bean name of the executor.
The executor is identified with this value by StackSaga engine. after configuring the bean name, it cannot be changed at all. if you want to the class package, it does not matter without changing the configured name.</para>
</callout>
<callout arearefs="CO9-5">
<para><emphasis role="strong">RevertAfterExecutor&lt;A, E&gt;</emphasis>: The Revert After Executor should be implemented from the <literal>RevertAfterExecutor&lt;A,E&gt;</literal>.
Generic <emphasis role="strong">A</emphasis> is the aggregator.
Generic <emphasis role="strong">E</emphasis> is the <link linkend="command_executor">command-executor</link> of the given aggregator as the Generic <emphasis role="strong">A</emphasis>.</para>
</callout>
<callout arearefs="CO9-6">
<para>Override the <literal>doProcess()</literal> method that <literal>RevertAfterExecutor</literal> provides.
That is the method is executed by the StackSaga engine.</para>
</callout>
<callout arearefs="CO9-7">
<para><emphasis role="strong">PlaceOrderAggregator</emphasis>: The final aggregator state when the process exception is thrown.</para>
</callout>
<callout arearefs="CO9-8">
<para><emphasis role="strong">ProcessStack</emphasis>: The final process stack when the process exception is thrown.</para>
</callout>
<callout arearefs="CO9-9">
<para><emphasis role="strong">NonRetryableExecutorException</emphasis>:The process-exception that was thrown by the last executor.</para>
</callout>
<callout arearefs="CO9-10">
<para><emphasis role="strong">RevertHintStore</emphasis> If you want to add some data to the backward process, you can use the <literal>RevertHintStore</literal> to put the data as container.</para>
</callout>
<callout arearefs="CO9-11">
<para><emphasis role="strong">RevertAfterStepManagerUtil&lt;A, E&gt;</emphasis>: This object provides the methods for giving the navigation to the engine regarding the next step. it can be another revert-after-executor or a revert-after completion.</para>
</callout>
<callout arearefs="CO9-12">
<para><emphasis role="strong">RetryableExecutorException</emphasis>: If the revert after execution is failed due to a retryable exception, you can provide that by warping with <literal>RetryableExecutorException</literal>.</para>
</callout>
<callout arearefs="CO9-13">
<para><emphasis role="strong">next()</emphasis>: You can provide (only if you have) the next revert-after-executor with <literal>revertStepManagerUtil.next()</literal>.</para>
</callout>
<callout arearefs="CO9-14">
<para><emphasis role="strong">complete()</emphasis>: If you don&#8217;t have any revert-after-executor to be executed as next regarding the command-executor, you can return <literal>revertStepManagerUtil.complete()</literal>.</para>
</callout>
</calloutlist>
</section>
</section>
<section xml:id="_processstack">
<title>ProcessStack</title>

</section>
<section xml:id="retryable_executor_exception">
<title>RetryableExecutorException</title>
<simpara>If you are having an exception while processing the executor due to a connection issue or that kind of re-invokable error (The exceptions that can be occurred temporarily), you can throw a <literal>RetryableExecutorException</literal>.
Then the StackSaga engine will temporarily pause the execution, and the transaction does expose to the next scheduler.
Because, the engine knows that even though the executor has an exception at this moment, the execution can be retried and run again successfully due to the retractable error.
IF you were unable to catch the exception properly, the execution might throw <literal>RuntimeException</literal> s.
That kind of unhandled exception will be caught as non-retryable exception by the StackSaga engine.
IF the exception is a <emphasis role="strong">non-retryable</emphasis> error, you can throw it by warping with <link linkend="non_retryable_executor_exception"><literal>NonRetryableExecutorException</literal></link>.</simpara>
<simpara><emphasis role="strong">Retryable Executor Exceptions</emphasis> are allowed for the following executors.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Executor</entry>
<entry align="left" valign="top">DoProcess() Method</entry>
<entry align="left" valign="top">doRevert() Method</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Query Executor</simpara></entry>
<entry align="left" valign="top"><simpara>✔</simpara></entry>
<entry align="left" valign="top"><simpara>✔</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Command Executor</simpara></entry>
<entry align="left" valign="top"><simpara>✔</simpara></entry>
<entry align="left" valign="top"><simpara>✔</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Revert Before Executor</simpara></entry>
<entry align="left" valign="top"><simpara>✔</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Revert After Executor</simpara></entry>
<entry align="left" valign="top"><simpara>✔</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<important>
<simpara>It is very important to identify whether the exception is a retryable exception or not.
If you don&#8217;t identify the exceptions that are thrown when the execution is executed every time that an exception is thrown, the transaction will be stopped to forward.
Therefore, it is necessary to capture and identify all the exceptions that are thrown inside the <literal>doProcess()</literal> method.</simpara>
</important>
<programlisting language="java" linenumbering="unnumbered">@SagaExecutor(
        executeFor = "user-service",
        liveCheck = true,
        value = "CheckUserExecutor"
)
@AllArgsConstructor
public class CheckUserExecutor implements QueryExecutor&lt;PlaceOrderAggregator&gt; {

    private final UserService userService;
    @Override
    public ProcessStepManager&lt;PlaceOrderAggregator&gt; doProcess(
            ProcessStack processStack,
            PlaceOrderAggregator aggregator,
            ProcessStepManagerUtil&lt;PlaceOrderAggregator&gt; stepManagerUtil
    ) throws RetryableExecutorException, NonRetryableExecutorException {

        try {

            ResponseEntity&lt;UserDetailDto&gt; userDetail = this.userService.getUserDetail(aggregator.getUsername());
            ...
        } catch (FeignException.ServiceUnavailable unavailableException) {
            throw RetryableExecutorException.buildWith(unavailableException).build();
        }
    }

}</programlisting>
</section>
<section xml:id="non_retryable_executor_exception">
<title>NonRetryableExecutorException</title>
<simpara>If you are having an exception while processing the executor that is not temporally occurred (The exceptions that have not any point of executing again), you can throw a <literal>NonRetryableExecutorException</literal>.
Then the StackSaga engine will stop the execution forward, and start reverting back, according to the configuration.</simpara>
<simpara>IF you were unable to catch the exception properly, the execution might throw <literal>RuntimeException</literal> s.
That kind of unhandled exception will be caught as <emphasis role="strong">non-retryable</emphasis> exception by the StackSaga engine as well.
But if you want to have proper error handling, you have to catch exceptions properly.</simpara>
<simpara><emphasis role="strong">Non-Retryable Executor Exceptions</emphasis> are allowed for the following executors.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Executor</entry>
<entry align="left" valign="top">DoProcess() Method</entry>
<entry align="left" valign="top">doRevert() Method</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Query Executor</simpara></entry>
<entry align="left" valign="top"><simpara>✔</simpara></entry>
<entry align="left" valign="top"><simpara>✖</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Command Executor</simpara></entry>
<entry align="left" valign="top"><simpara>✔</simpara></entry>
<entry align="left" valign="top"><simpara>✖</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Revert Before Executor</simpara></entry>
<entry align="left" valign="top"><simpara>✖</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Revert After Executor</simpara></entry>
<entry align="left" valign="top"><simpara>✖</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<note>
<simpara>You can see in the summary table, all the revert executions are not allowed <literal>NonRetryableExecutorException</literal> s.
The reason for that is according to the StackSaga architecture, any <emphasis role="strong">command-execution</emphasis> can have revert execution (compensation execution).
But all the <emphasis role="strong">revert-executions</emphasis> can have retryable-exception only.
Because, even though the process can be failed, the revert execution cannot be failed at all.
If the process is failed, there is a revert execution to have a compensation.
But if the revert is failed, there are any other executions to have compensation for the reverting fail.<?asciidoc-br?>
<emphasis role="strong">The summary is that only forward execution can have non-retryable-exception.</emphasis></simpara>
</note>
<programlisting language="java" linenumbering="unnumbered">@SagaExecutor(
        executeFor = "user-service",
        liveCheck = true,
        value = "CheckUserExecutor"
)
@AllArgsConstructor
public class CheckUserExecutor implements QueryExecutor&lt;PlaceOrderAggregator&gt; {

    private final UserService userService;

    @Override
    public ProcessStepManager&lt;PlaceOrderAggregator&gt; doProcess(
            ProcessStack processStack,
            PlaceOrderAggregator aggregator,
            ProcessStepManagerUtil&lt;PlaceOrderAggregator&gt; stepManagerUtil
    ) throws RetryableExecutorException, NonRetryableExecutorException {

        try {

            ResponseEntity&lt;UserDetailDto&gt; userDetail = this.userService.getUserDetail(aggregator.getUsername());
            ...
        } catch (FeignException.ServiceUnavailable unavailableException) {
            throw RetryableExecutorException
                    .buildWith(unavailableException)
                    .build();
        } catch (FeignException.BadRequest badRequestException) {
            <co xml:id="CO10-1"/>
            throw NonRetryableExecutorException
                    .buildWith(badRequestException)
                    .put("time", LocalDateTime.now())  <co xml:id="CO10-2"/>
                    .put("reason", "BadRequest") <co xml:id="CO10-3"/>
                    ...
                    .build();
        }
    }

}</programlisting>
<calloutlist>
<callout arearefs="CO10-1">
<para><emphasis role="strong">NonRetryableExecutorException</emphasis> is thrown due to the exception is a <literal>BadRequest</literal>. specially <literal>NonRetryableExecutorException</literal> provides a way to add the metadata regarding the exception.</para>
</callout>
<callout arearefs="CO10-2 CO10-3">
<para>Put the metadata regarding exception as a key and value. <anchor xml:id="stacksaga_exception_wrapping" xreflabel="[stacksaga_exception_wrapping]"/></para>
</callout>
</calloutlist>
<note>
<simpara>In java, we usually pass the data regarding the exception with the exception object.
But in the StackSaga it is <emphasis role="strong">not recommended</emphasis>.
Because, any time any object can be serialized (even Exceptions) for saving to the event-store.
Serializing an exception object (like Json or XML) is not easy, and it might be a performance issue without any benefit.
And also most of the time if you pass a complex exception, it might throw an exception when it is serialized.
Therefore, StackSaga engine just saves your exception as a string in the event-store(Only for seeing through the Admin-Dashboard).
If you want to put some metadata to the backward regarding the exception,
<emphasis role="strong">NonRetryableExecutorException</emphasis> has a method to put the data as key and value pare called <literal>put(key, value)</literal>.
You can put any number of key/value pare into that by using the put method.</simpara>
</note>
<important>
<simpara>There is nothing like you can throw an exception when some exception is occurred.
If you don&#8217;t want to continue the execution of the transaction to forward, and if you decide that the transaction should be stopped at some point, due to a condition is not met, you can throw a <emphasis role="strong">NonRetryableExecutorException</emphasis> exception as well.
<link linkend="usage_of_exceptions">See the full implementation</link></simpara>
</important>
</section>
<section xml:id="usage_of_exceptions">
<title>Usage of Executors[Q&amp;C] With Exceptions </title>
<simpara>Here you can see how you can handle the <emphasis role="strong">success</emphasis>,
<emphasis role="strong">failure</emphasis> and <emphasis role="strong">retryable</emphasis> scenario inside the <emphasis role="strong"><link linkend="query_executor">query-executor</link></emphasis> executor.
In the same way, you can handle all things in <emphasis role="strong"><link linkend="command_executor">command-executor</link></emphasis> as well.</simpara>
<simpara>Create your own exception annotating with <literal><link linkend="saga_exception_annotation">@SagaException</link></literal>  class to handle to inactive user exception.</simpara>
<simpara>The executor gets the userdata from the user-service by calling another service.
Based on the return of the <literal>userService.getUserDetail</literal>  method, the next step is managed here.
If the user is in active mode, The current executor allows the next executor by providing the next executor that should be invoked to the StackSaga engine.</simpara>
<programlisting language="java" linenumbering="unnumbered">@SagaExecutor(
        executeFor = "user-service",
        liveCheck = true,
        value = "CheckUserExecutor"
)
@AllArgsConstructor
public class CheckUserExecutor implements QueryExecutor&lt;PlaceOrderAggregator&gt; {

    private final UserService userService;

    @Override
    public ProcessStepManager&lt;PlaceOrderAggregator&gt; doProcess(
            ProcessStack processStack,
            PlaceOrderAggregator aggregator,
            ProcessStepManagerUtil&lt;PlaceOrderAggregator&gt; stepManagerUtil
    ) throws RetryableExecutorException, NonRetryableExecutorException {

        try {
            ResponseEntity&lt;UserDetailDto&gt; userDetail = this.userService.getUserDetail(aggregator.getUsername());
            if (userDetail.getBody().getIsActive() == 1) {
                return stepManagerUtil.next(DispatchOrderExecutor.class); <co xml:id="CO11-1"/>
            } else {
                UserInactiveException inactiveException = new UserInactiveException("User is not active!"); <co xml:id="CO11-2"/>
                throw NonRetryableExecutorException
                        .buildWith(inactiveException)
                        .build();
            }
        } catch (FeignException.ServiceUnavailable unavailableException) {
            throw RetryableExecutorException
                    .buildWith(unavailableException)
                    .build(); <co xml:id="CO11-3"/>
        } catch (FeignException.BadRequest badRequestException) {
            throw NonRetryableExecutorException
                    .buildWith(badRequestException)
                    .put("test", LocalDateTime.now())
                    .put("reason", "BadRequest")
                    .build(); <co xml:id="CO11-4"/>
        }
    }
}</programlisting>
<calloutlist>
<callout arearefs="CO11-1">
<para><emphasis role="strong">Success scenario</emphasis>:
If the user is active, the next executor will be provided to the engine by using <literal>stepManagerUtil.next()</literal> method.</para>
</callout>
<callout arearefs="CO11-2">
<para><emphasis role="strong">Failed scenario</emphasis>:
IF the user is inactive, the process is stopped to forward by throwing <literal>NonRetryableExecutorException</literal> with <literal>UserInactiveException</literal>.</para>
</callout>
<callout arearefs="CO11-3">
<para><emphasis role="strong">Failed scenario</emphasis>:
IF the <literal>userService.getUserDetail()</literal> service throw a <literal>FeignException.BadRequest</literal> exception, the process is stopped to forward by throwing <literal>NonRetryableExecutorException</literal> with <literal>FeignException.BadRequest</literal> that occurred.</para>
</callout>
<callout arearefs="CO11-4">
<para><emphasis role="strong">Retryable scenario</emphasis>
IF the <literal>userService.getUserDetail()</literal> service throw a <literal>FeignException.ServiceUnavailable</literal> exception, the process is stopped temporally by throwing <literal>NonRetryableExecutorException</literal> with <literal>FeignException.ServiceUnavailable</literal> that occurred.</para>
</callout>
</calloutlist>
</section>
<section xml:id="saga_exception_annotation">
<title>@SagaException Annotation </title>
<simpara>If you want to throw an exception as a <link linkend="non_retryable_executor_exception">NonRetryableExecutorException</link>, The framework suggests you to create a new exception for that by warping the real exception and specially that can be annotated with <literal>@SagaException</literal> annotation like below.</simpara>
<important>
<simpara>Make sure to don&#8217;t add the variables for exception metadata in your new exception class.
Keep the exception class clear.
Because, the framework does provide another way to provide the metadata in <link linkend="stacksaga_exception_wrapping">NonRetryableExecutorException</link></simpara>
</important>
<programlisting language="java" linenumbering="unnumbered">@SagaException(name = "UserInactiveException") <co xml:id="CO12-1"/>
public class UserInactiveException extends RuntimeException {
    //for just throw an exception.
    public UserInactiveException() {
    }

    //for just throw an exception with message.
    public UserInactiveException(String message) {
        super(message);
    }

    //for wrapping the exception.
    public UserInactiveException(String message, Throwable cause) {
        super(message, cause);
    }
}</programlisting>
<calloutlist>
<callout arearefs="CO12-1">
<para>According to the <link linkend="usage_of_exceptions">usage of exceptions example</link>, you can see this exception is used to throw if the user is inactive.
And also if you think the package of the exception class will be changed in some cases in the future, you can set a fixed name for the exception.
By annotating <literal>@SagaException</literal>.</para>
</callout>
</calloutlist>
<simpara>At the first glance, you might think that there is no point in annotating by <literal>@SagaException</literal> when it is thrown.
However, it is important when it is used in the revert executions (revert execution of the <link linkend="command_executor">command executors</link> or <link linkend="revert_after_executor">revert after</link> or <link linkend="revert_before_executor">revert before</link>).
As you know, the revert process goes through revert method of each and every <link linkend="command_executor">command executors</link> that successfully executed in the past regarding the transaction.
Then you have to check what is the real exception that was thrown, and what is the metadata that you want to make the decisions.
As an example, just imagine that there is an event in the event-store to be executed.
While the event is in the event-store, a new version is released of the particular service.
And also the exception class has been moved to another package by mistake, or as a requirement.
But while then, the old event is trying to be invoked through the StackSaga engine with old data.
However, At this moment the exception class that caused the exception does not exist in the path when the exception was thrown initially.</simpara>
<simpara>you can use the following methods that <literal>NonRetryableExecutorException</literal> does provide for checking the exception in the revert process.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><literal>getRealExceptionName()</literal>: Get the name with the path of the exception class that was thrown.
(This name is provided by the framework when the exception is thrown).</simpara>
</listitem>
<listitem>
<simpara><literal>getRealExceptionSimpleName()</literal>: Get just the name of the exception class that was thrown.
(This name is provided by the framework when the exception is thrown).</simpara>
</listitem>
<listitem>
<simpara><literal><emphasis role="strong">getRealSagaExceptionName()</emphasis></literal>: Get the name that has been given with <literal>@SagaException</literal> annotation.</simpara>
</listitem>
</orderedlist>
<note>
<simpara>You can get the <literal>Real Saga Exception Name</literal> only if you have annotated with <literal>@SagaException</literal> annotation.</simpara>
</note>
<simpara>Here you can see an example of how you can use <literal>SagaException</literal> in the revert process.</simpara>
<programlisting language="java" linenumbering="unnumbered">@SagaExecutor(
        executeFor = "stock-management-service",
        liveCheck = true,
        value = "UpdateStockExecutor"
)
@AllArgsConstructor
public class UpdateStockExecutor implements CommandExecutor&lt;PlaceOrderAggregator&gt; {


    @Override
    public ProcessStepManager&lt;PlaceOrderAggregator&gt; doProcess(
            ProcessStack processStack,
            PlaceOrderAggregator aggregator,
            ProcessStepManagerUtil&lt;PlaceOrderAggregator&gt; stepManager
    ) throws RetryableExecutorException, NonRetryableExecutorException {
        ...
    }

    @Override
    public void doRevert(
            ProcessStack previousProcessStack,
            NonRetryableExecutorException realException,
            PlaceOrderAggregator finalAggregateState,
            RevertHintStore revertHintStore
    ) throws RetryableExecutorException {

        realException.getRealSagaExceptionName().ifPresent(realSagaExceptionName -&gt; {<co xml:id="CO13-1"/>
            if (realSagaExceptionName.equals("UserInactiveException")) {<co xml:id="CO13-2"/>
                <co xml:id="CO13-3"/>
                realException.get("reason").ifPresent(reason -&gt; {
                    if (reason.equalsIgnoreCase("BadRequest")) {
                        //do the revert process
                    }
                });
            }
        });
    }
}</programlisting>
<calloutlist>
<callout arearefs="CO13-1">
<para>You can get the <literal>RealSagaExceptionName</literal> by calling <literal>getRealSagaExceptionName()</literal> method.
And if you have annotated the exception class with <literal>@SagaException</literal> annotation when the exception was thrown, it will return a <literal>Optional&lt;String&gt;</literal> object with the name that has been mentioned in the <literal>@SagaException</literal> annotation.
Or otherwise, the object will be empty.</para>
</callout>
<callout arearefs="CO13-2">
<para>check the equality of Saga exception name with the exception that you want.</para>
</callout>
<callout arearefs="CO13-3">
<para>due to that, the exception is the exact same, you can get and check the metadata of the exception that you have given at the moment the exception was thrown.</para>
</callout>
</calloutlist>
</section>
<section xml:id="saga_revert_hint_store">
<title>RevertHintStore</title>
<simpara><literal>RevertHintStore</literal> does provide you a map to put the data that the revert processes want.
After having a <link linkend="non_retryable_executor_exception">NonRetryableExecutorException</link>, the engine will start the revert process by stopping to forward anymore.
You know already, when the transaction going forward, you can update or add the data in the aggregator object.
But when it is starting to revert, you cannot change the values in the aggregator object anymore.
Because the aggregator object is frozen.
Therefore, you should have to have a way to carry out the data to the backwards as well.
To overcome that problem, the system provides the RevertHintStore object to add your extra hints that are necessary for the revert process through each executor.
After adding the data in the <literal>RevertHintStore</literal> object, you can read that data from other next revert-processes.</simpara>
<simpara>Here you can see an implementation for revert method of one of command executors.
<literal>RevertHintStore</literal> can be used in all revert processes like <link linkend="revert_before_executor">revert-before</link>,
<link linkend="revert_after_executor">revert-after</link> executors as well.</simpara>
<programlisting language="java" linenumbering="unnumbered">@SagaExecutor(
        executeFor = "delivery-service",
        liveCheck = true,
        value = "DispatchOrderExecutor"
)
public class DispatchOrderExecutor implements CommandExecutor&lt;PlaceOrderAggregator&gt; {


    @Override
    public ProcessStepManager&lt;PlaceOrderAggregator&gt; doProcess(
            ProcessStack processStack,
            PlaceOrderAggregator aggregator,
            ProcessStepManagerUtil&lt;PlaceOrderAggregator&gt; stepManager
    ) throws RetryableExecutorException, NonRetryableExecutorException {
        //
    }

    @Override
    public void doRevert(ProcessStack processStack,
                         NonRetryableExecutorException realException,
                         PlaceOrderAggregator aggregator,
                         RevertHintStore revertHintStore
    ) throws RetryableExecutorException {

        revertHintStore
                .get("MakePaymentExecutor") <co xml:id="CO14-1"/>
                .ifPresent(makePaymentExecutor -&gt; {
                    if (makePaymentExecutor.equalsIgnoreCase("success")) {
                        <co xml:id="CO14-2"/>
                        revertHintStore.put("last_updated_time", LocalDateTime.now().toString());
                        <co xml:id="CO14-3"/>
                        revertHintStore.put("DispatchOrderExecutor", "success");
                    }
                });
        ...
    }
}</programlisting>
<calloutlist>
<callout arearefs="CO14-1">
<para>Obtaining the <literal>RevertHintStore</literal> data (Key: MakePaymentExecutor) that have been added in another revert process before.
If the value exists in the <literal>RevertHintStore</literal> you will have an <literal>Optional&lt;String&gt;</literal> object with the data.</para>
</callout>
<callout arearefs="CO14-2 CO14-3">
<para>Based on the <literal>RevertHintStore</literal> 's old data that bes been added by another executor, adding another data into the <literal>RevertHintStore</literal>.
This value will be helpful for the next revert process.</para>
</callout>
</calloutlist>
</section>
<section xml:id="saga_event_handler">
<title>Saga Execution Event Listener </title>
<simpara><literal>SagaExecutionEventListener</literal> is the place where you&#8217;re notified about each and every action during the process by the SEC.
As an example, you hand over your transaction to the StackSaga engine by mentioning the starting executor.
After handing over, the engine will invoke your executors one by one.
During the process, the engine does provide some events regarding the execution to notify.
To get notified, you can create a separate EventListener classes for each and every <link linkend="creating_aggregator_class">Aggregator</link>.
For creating the EventListeners, the EventListeners should be implemented from <literal>ExecutionEventListener&lt;A&gt;</literal> interface.
<literal>A</literal> is the Aggregator class that you want to get notified.
And also the class should be annotated with <literal><emphasis role="strong">@SagaExecutionEventListener</emphasis></literal>  or <literal>@<emphasis role="strong">SagaAsyncExecutionEventListener</emphasis></literal>.
Those annotations provide Spring bean capabilities for your implementation as well.</simpara>
<note>
<simpara>If you want to call the event methods in <emphasis role="strong">Async-mode</emphasis>  inside the handler, the handler class can be annotated with <literal>@SagaAsyncExecutionEventListener</literal> instead of <literal>@SagaExecutionEventListener</literal>.
Then it will run the event methods in separate threads asynchronously.</simpara>
</note>
<warning>
<simpara>Make sure to not use spring <literal>@Async</literal> annotation with each method inside the listener or the entire class.
Because StackSaga does create a separate thread pool for executing the event methods and also, you can customize it as per the requirements.</simpara>
</warning>
<simpara><literal>ExecutionEventListener&lt;A&gt;</literal> provides the following events to be notified.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><literal><emphasis role="strong">onEachProcessPerformed</emphasis></literal></simpara>
<itemizedlist>
<listitem>
<simpara>This method will be invoked after executing each sub process successfully.
— Just think about our example.
After payment process success, the order status should be updated as payment successful and also after successfully dispatched the order, the order status should be updated as order dispatched.
And just think, you want to update your customer by sending an email after the payment process and after dispatching the process.
Handler is the place that you can invoke your processes.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><literal><emphasis role="strong">onEachRevertPerformed</emphasis></literal></simpara>
<itemizedlist>
<listitem>
<simpara>This is the opposite of the onEachProcess.
That works after every successful process.
If the whole transaction has to be reverted at some point, the compensation process starts from that point.
Then the revert method of each executed executor starts to be executed as the compensations.
If you want to get notified after each compensation, onEachRevert method will be invoked by the framework with all the data that you want.<?asciidoc-br?>
According to the example, if the payment process is failed, you have to update the order status as payment failed.
This kind of execution can be proceeded in this method.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><literal><emphasis role="strong">onTransactionCompleted</emphasis></literal></simpara>
<itemizedlist>
<listitem>
<simpara>There are two meanings of transaction-complete.
One is that the transaction was processed without any process exception.
When considering the example the create-order success, user checking is successful, make payment is success, increase point is success, and finally dispatching the order is also success.
The 2nd success is, a process exception was happened and after that all the relevant compensation has been processed successfully.
(That means a revert error hasn&#8217;t been occurred while the compensation process) otherwise we can say the compensation has been processed smoothly without any exceptions.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><literal><emphasis role="strong">onProcessException</emphasis></literal></simpara>
<itemizedlist>
<listitem>
<simpara>This is not relevant to the sub process.
That means the process exception can be happened only one time in the entire process.
When considering the example, you are going to dispatch the order, and it is failed because of non-retryable exception.
(Just think the order is not existing in the database) then the compensation process will be started.
This is the turning point to compensation start.
At that time, this method will be invoked by the framework with the data that you want.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><literal><emphasis role="strong">onTransactionTerminated</emphasis></literal></simpara>
<itemizedlist>
<listitem>
<simpara>According to the flow, any revert process can&#8217;t have non-retryable exception.
That is the rule.
But sometimes the programmer may haven&#8217;t been handled that.
Then the revert process also can&#8217;t be processed anymore.
Then the framework marks that transaction as a garbage transaction and terminates the process.
This is a very rare case.
But it can be happened.</simpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
<tip>
<simpara>In <literal>ExecutionEventListener</literal>, all the abstract methods are default.
Therefore, you don&#8217;t want to override all the methods, and you can only override the methods that you want as per the requirement.
And also you can create multiple listeners for the target Aggregator.</simpara>
</tip>
<simpara>Here you can see an example how you can create a listener of <literal>ExecutionEventListener</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">@SagaExecutionEventListener
public class PlaceOrderEventListener implements ExecutionEventListener&lt;PlaceOrderAggregator&gt; {
    @Override
    public void onEachProcessPerformed(Class&lt;? extends SagaExecutor&lt;? extends SagaAggregate&gt;&gt; processedExecutor, PlaceOrderAggregator currentAggregate) {
        //do whatever you want
    }

    @Override
    public void onEachRevertPerformed(Class&lt;? extends SagaExecutor&lt;? extends SagaAggregate&gt;&gt; revertedExecutor, PlaceOrderAggregator finalAggregateState, NonRetryableExecutorException nonRetryableExecutorException, RevertHintStore revertHintStore) {
        //do whatever you want
    }

    @Override
    public void onTransactionCompleted(TransactionCompletedDetail&lt;PlaceOrderAggregator&gt; transactionCompletedDetail, CompleteStatus completeStatus) {
        //do whatever you want
    }

    @Override
    public void onTransactionTerminated(TransactionTerminationDetail&lt;PlaceOrderAggregator&gt; transactionTerminationDetail) {
        //do whatever you want
    }

    @Override
    public void onProcessException(PlaceOrderAggregator finalAggregateState, NonRetryableExecutorException exception, Class&lt;? extends SagaExecutor&lt;? extends SagaAggregate&gt;&gt; executorClass) {
        //do whatever you want
    }
}</programlisting>
</section>
<section xml:id="saga_template">
<title>SagaTemplate&lt;A&gt;</title>
<simpara><literal>SagaTemplate</literal> is the class which is responsible for starting the StackSaga engine to invoke your transaction.
By providing the necessary data, you can say to start the process of the transaction for StackSaga engine.
<literal>SagaTemplate</literal> is an instance, and it provides one method called <literal>process(&#8230;&#8203;)</literal> for starting the process.</simpara>
<note>
<simpara><literal>SagaTemplate</literal> Is a spring bean that you can Autowire (Injectable) in Spring environment.
You can autowire it by using spring @Autowire annotation or by creating the constructor.</simpara>
</note>
<programlisting language="java" linenumbering="unnumbered">@RestController
@RequestMapping("/order")
@AllArgsConstructor
public class PlaceOrderSagaController {

    private final SagaTemplate&lt;PlaceOrderAggregator&gt; sagaTemplate; <co xml:id="CO15-1"/>

    @PostMapping
    @ResponseStatus(HttpStatus.ACCEPTED)
    public Map&lt;String, String&gt; placeOrder() {
        <co xml:id="CO15-2"/>
        PlaceOrderAggregator aggregator = new PlaceOrderAggregator();
        aggregator.setUsername("mafei");
        aggregator.setTotal(200.00);

        <co xml:id="CO15-3"/>
        this.sagaTemplate.process(
                aggregator,
                CheckUserExecutor.class
        );
        <co xml:id="CO15-4"/>
        return Collections.singletonMap(
                "order_id",
                aggregator.getAggregateTransactionId()
        );
    }
}</programlisting>
<calloutlist>
<callout arearefs="CO15-1">
<para>Autowire(inject) the <literal>SagaTemplate</literal> by providing the target <link linkend="creating_aggregator_class">Aggregator</link> Class.</para>
</callout>
<callout arearefs="CO15-2">
<para>Initialize your aggregator by providing the initial data.</para>
</callout>
<callout arearefs="CO15-3">
<para>Use the autowired <literal>SagaTemplate</literal> object and call the <literal>process(..)</literal> method.
As the first argument, you have to provide the initialized target aggregator object.
As the second argument you have to provide, which is the first executor that should be started the transaction.
According to the example, The 1st executor is <literal>CheckUserExecutor.class</literal>.
It can be either <link linkend="command_executor">Command-Executor</link> or <link linkend="query_executor">Query-Executor</link>.</para>
</callout>
<callout arearefs="CO15-4">
<para>Returns the response by obtaining the aggregatorTransactionId from the initialized object.</para>
</callout>
</calloutlist>
<note>
<simpara>Due to the fact that the target aggregator class has been extended from the <literal>SagaAggregate</literal>, you can use inherited methods from <literal>SagaAggregate</literal> class. <literal>getAggregateTransactionId()</literal> method is one of inherited methods from <literal>SagaAggregate</literal> class.
It will provide you the <emphasis role="strong">unique ID</emphasis> for each object (each transaction) that you initialize.
It will be the transaction id for the entire transaction.</simpara>
</note>
<simpara><?asciidoc-hr?></simpara>
<tip>
<simpara>Even though <literal>SagaTemplate&lt;A&gt;</literal> can be autowired anywhere in the application, As the best practice it is recommended to use <literal>SagaTemplate&lt;A&gt;</literal> inside of an <literal>EventHandler</literal> class according to the StackSaga design pattern called <link linkend="test">CHES</link>.</simpara>
</tip>
</section>
<section xml:id="saga_trash_listener">
<title>TrashFileListener</title>
<simpara><literal>TrashFileListener</literal> is used to be notified about the <emphasis role="strong">Trash-Files</emphasis>.</simpara>
</section>
<section xml:id="custom_thread_pool_configuration">
<title>Custom Thread-pool configuration</title>
<simpara>In StackSaga framework, there are several thread-pools are used behind the scene with default configurations.
All the executions are not executed with a single thread-pool to ensure the resiliency of the application.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Thread-pools in StackSaga framework</title>
<tgroup cols="9">
<colspec colname="col_1" colwidth="11.1111*"/>
<colspec colname="col_2" colwidth="11.1111*"/>
<colspec colname="col_3" colwidth="11.1111*"/>
<colspec colname="col_4" colwidth="11.1111*"/>
<colspec colname="col_5" colwidth="11.1111*"/>
<colspec colname="col_6" colwidth="11.1111*"/>
<colspec colname="col_7" colwidth="11.1111*"/>
<colspec colname="col_8" colwidth="11.1111*"/>
<colspec colname="col_9" colwidth="11.1112*"/>
<thead>
<row>
<entry align="left" valign="top">pool-name</entry>
<entry align="left" valign="top">Provider Interface</entry>
<entry align="left" valign="top">dependency</entry>
<entry align="left" valign="top">default-implementation</entry>
<entry align="left" valign="top">prefix</entry>
<entry align="left" valign="top">core pool size</entry>
<entry align="left" valign="top">max pool size</entry>
<entry align="left" valign="top">Queue Capacity</entry>
<entry align="left" valign="top">WaitOnShutdown</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><link linkend="saga_discovery_transaction_task_executor"><literal>SagaDiscoveryTransactionTaskExecutor</literal></link></simpara></entry>
<entry align="left" valign="top"><simpara><literal>SagaDiscoveryTransactionTaskExecutorProvider</literal></simpara></entry>
<entry align="left" valign="top"><simpara><phrase role="nowrap"><literal>stacksaga-spring-boot-starter-core</literal></phrase></simpara></entry>
<entry align="left" valign="top"><simpara><literal>SagaDiscoveryTransactionTaskExecutorProviderDefault</literal></simpara></entry>
<entry align="left" valign="top"><simpara><phrase role="nowrap"><emphasis role="strong">saga-tx-</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara><phrase role="nowrap">Available Processors * 1</phrase></simpara></entry>
<entry align="left" valign="top"><simpara><phrase role="nowrap">Available Processors * 3</phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Default</simpara></entry>
<entry align="left" valign="top"><simpara>True</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="saga_event_task_executor"><literal>SagaEventTaskExecutor</literal></link></simpara></entry>
<entry align="left" valign="top"><simpara><literal>SagaEventTaskExecutorProvider</literal></simpara></entry>
<entry align="left" valign="top"><simpara><phrase role="nowrap"><literal>stacksaga-spring-boot-starter-core</literal></phrase></simpara></entry>
<entry align="left" valign="top"><simpara><literal>SagaEventExecutorProviderDefault</literal></simpara></entry>
<entry align="left" valign="top"><simpara><phrase role="nowrap"><emphasis role="strong">saga-event-</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara><phrase role="nowrap">Available Processors * 1</phrase></simpara></entry>
<entry align="left" valign="top"><simpara><phrase role="nowrap">Available Processors * 2</phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Default</simpara></entry>
<entry align="left" valign="top"><simpara>True</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="saga_admin_task_executor"><literal>SagaAdminTaskExecutor</literal></link></simpara></entry>
<entry align="left" valign="top"><simpara><literal>SagaAdminTaskExecutorProvider</literal></simpara></entry>
<entry align="left" valign="top"><simpara><phrase role="nowrap"><literal>stacksaga-spring-boot-starter-discovery</literal></phrase></simpara></entry>
<entry align="left" valign="top"><simpara><literal>SagaAdminTaskExecutorProviderDefault</literal></simpara></entry>
<entry align="left" valign="top"><simpara><phrase role="nowrap"><emphasis role="strong">saga-admin-</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>5</simpara></entry>
<entry align="left" valign="top"><simpara>Default</simpara></entry>
<entry align="left" valign="top"><simpara>True</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="saga_discovery_file_task_executor"><literal>SagaDiscoveryFileTaskExecutor</literal></link></simpara></entry>
<entry align="left" valign="top"><simpara><literal>SagaDiscoveryFileTaskExecutorProvider</literal></simpara></entry>
<entry align="left" valign="top"><simpara><phrase role="nowrap"><literal>stacksaga-spring-boot-starter-discovery</literal></phrase></simpara></entry>
<entry align="left" valign="top"><simpara><literal>SagaDiscoveryFileTaskExecutorProviderDefault</literal></simpara></entry>
<entry align="left" valign="top"><simpara><phrase role="nowrap"><emphasis role="strong">saga-file-</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara><phrase role="nowrap">Available Processors * 1</phrase></simpara></entry>
<entry align="left" valign="top"><simpara><phrase role="nowrap">Available Processors * 2</phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Default</simpara></entry>
<entry align="left" valign="top"><simpara>True</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="saga_discovery_retry_transaction_task_executor"><literal>SagaDiscoveryRetryTransactionTaskExecutor</literal></link></simpara></entry>
<entry align="left" valign="top"><simpara><literal>SagaDiscoveryRetryTransactionTaskExecutorProvider</literal></simpara></entry>
<entry align="left" valign="top"><simpara><phrase role="nowrap"><literal>stacksaga-spring-boot-starter-discovery</literal></phrase></simpara></entry>
<entry align="left" valign="top"><simpara><literal>SagaDiscoveryRetryTransactionTaskExecutorProviderDefault</literal></simpara></entry>
<entry align="left" valign="top"><simpara><phrase role="nowrap"><emphasis role="strong">saga-R-tx-</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara><phrase role="nowrap">Available Processors * 1</phrase></simpara></entry>
<entry align="left" valign="top"><simpara><phrase role="nowrap">Available Processors * 2</phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Default</simpara></entry>
<entry align="left" valign="top"><simpara>True</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>In case if you want to change the default configuration, you can do it by implementing following</simpara>
<section xml:id="saga_discovery_transaction_task_executor">
<title>Saga Discovery Transaction TaskExecutor</title>
<simpara><literal>SagaDiscoveryTransactionTaskExecutor</literal> is the main pool. because this thread-pool is used for starting your transaction when it is called the <link linkend="saga_template"><literal>SagaTemplate.process()</literal></link> method. after starting the transaction, this thread-pool will handle all the executions of the executors.</simpara>
<simpara>— In case if you want to customize the default configuration, you can update the default configuration as follows:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Component <co xml:id="CO16-1"/>
public class CustomSagaDiscoveryTransactionTaskExecutor
    implements SagaDiscoveryTransactionTaskExecutorProvider { <co xml:id="CO16-2"/>

    @Override
    public ThreadPoolTaskExecutor getTaskExecutor() {
        <co xml:id="CO16-3"/>
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(Runtime.getRuntime().availableProcessors() * 5);
        ...
        return executor;
    }
}</programlisting>
<calloutlist>
<callout arearefs="CO16-1">
<para>Mark the class as a spring <literal>@Component</literal> (bean).</para>
</callout>
<callout arearefs="CO16-2">
<para>Implement the custom task-executor provider class from <literal>SagaDiscoveryTransactionTaskExecutorProvider</literal> and override the <literal>getTaskExecutor()</literal> method.</para>
</callout>
<callout arearefs="CO16-3">
<para>Provide your custom task-executor configurations by creating a new instance of <link xl:href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/concurrent/ThreadPoolTaskExecutor.html"><literal>ThreadPoolTaskExecutor</literal></link>.</para>
</callout>
</calloutlist>
<note>
<simpara>Even though you change the prefix of the thread-pool when the task-executor is created, the prefix is restored for maintaining the thread-name uniqueness. <link linkend="custom_thread_pool_configuration">See the prefix of each thread-pool</link>.</simpara>
</note>
<simpara><?asciidoc-hr?></simpara>
</section>
<section xml:id="saga_event_task_executor">
<title>Saga Event TaskExecutor</title>
<simpara>— In case if you want to customize the default configuration, you can update the default configuration as follows:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Component <co xml:id="CO17-1"/>
public class CustomSagaEventTaskExecutor implements SagaEventTaskExecutorProvider { <co xml:id="CO17-2"/>
    @Override
    public ThreadPoolTaskExecutor getTaskExecutor() {
        <co xml:id="CO17-3"/>
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(Runtime.getRuntime().availableProcessors() * 5);
        ...
        return executor;
    }
}</programlisting>
<calloutlist>
<callout arearefs="CO17-1">
<para>Mark the class as a spring <literal>@Component</literal> (bean).</para>
</callout>
<callout arearefs="CO17-2">
<para>Implement the custom task-executor provider class from <literal>SagaEventTaskExecutorProvider</literal> and override the <literal>getTaskExecutor()</literal> method.</para>
</callout>
<callout arearefs="CO17-3">
<para>Provide your custom task-executor configurations by creating a new instance of <link xl:href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/concurrent/ThreadPoolTaskExecutor.html"><literal>ThreadPoolTaskExecutor</literal></link>.</para>
</callout>
</calloutlist>
<note>
<simpara>Even though you change the prefix of the thread-pool when the task-executor is created, the prefix is restored for maintaining the thread-name uniqueness. <link linkend="custom_thread_pool_configuration">See the prefix of each thread-pool</link>.</simpara>
</note>
<simpara><?asciidoc-hr?></simpara>
</section>
<section xml:id="saga_admin_task_executor">
<title>Saga Admin TaskExecutor</title>
<simpara>— In case if you want to customize the default configuration, you can update the default configuration as follows:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Component <co xml:id="CO18-1"/>
public class CustomSagaAdminTaskExecutor
    implements SagaAdminTaskExecutorProvider {<co xml:id="CO18-2"/>

    @Override
    public ThreadPoolTaskExecutor getTaskExecutor() {
        <co xml:id="CO18-3"/>
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(Runtime.getRuntime().availableProcessors() * 5);
        ...
        return executor;
    }
}</programlisting>
<calloutlist>
<callout arearefs="CO18-1">
<para>Mark the class as a spring <literal>@Component</literal> (bean).</para>
</callout>
<callout arearefs="CO18-2">
<para>Implement the custom task-executor provider class from <literal>SagaAdminTaskExecutorProvider</literal> and override the <literal>getTaskExecutor()</literal> method.</para>
</callout>
<callout arearefs="CO18-3">
<para>Provide your custom task-executor configurations by creating a new instance of <link xl:href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/concurrent/ThreadPoolTaskExecutor.html"><literal>ThreadPoolTaskExecutor</literal></link>.</para>
</callout>
</calloutlist>
<note>
<simpara>Even though you change the prefix of the thread-pool when the task-executor is created, the prefix is restored for maintaining the thread-name uniqueness. <link linkend="custom_thread_pool_configuration">See the prefix of each thread-pool</link>.</simpara>
</note>
<simpara><?asciidoc-hr?></simpara>
</section>
<section xml:id="saga_discovery_file_task_executor">
<title>Saga Discovery File TaskExecutor</title>
<simpara>— In case if you want to customize the default configuration, you can update the default configuration as follows:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Component <co xml:id="CO19-1"/>
public class CustomSagaDiscoveryFileTaskExecutor
    implements SagaDiscoveryFileTaskExecutorProvider { <co xml:id="CO19-2"/>

    @Override
    public ThreadPoolTaskExecutor getTaskExecutor() {
        <co xml:id="CO19-3"/>
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(Runtime.getRuntime().availableProcessors() * 5);
        ...
        return executor;
    }
}</programlisting>
<calloutlist>
<callout arearefs="CO19-1">
<para>Mark the class as a spring <literal>@Component</literal> (bean).</para>
</callout>
<callout arearefs="CO19-2">
<para>Implement the custom task-executor provider class from <literal>SagaDiscoveryFileTaskExecutorProvider</literal> and override the <literal>getTaskExecutor()</literal> method.</para>
</callout>
<callout arearefs="CO19-3">
<para>Provide your custom task-executor configurations by creating a new instance of <link xl:href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/concurrent/ThreadPoolTaskExecutor.html"><literal>ThreadPoolTaskExecutor</literal></link>.</para>
</callout>
</calloutlist>
<note>
<simpara>Even though you change the prefix of the thread-pool when the task-executor is created, the prefix is restored for maintaining the thread-name uniqueness. <link linkend="custom_thread_pool_configuration">See the prefix of each thread-pool</link>.</simpara>
</note>
<simpara><?asciidoc-hr?></simpara>
</section>
<section xml:id="saga_discovery_retry_transaction_task_executor">
<title>Saga Discovery Retry Transaction TaskExecutor</title>
<simpara>Even though the transaction is started by the <link linkend="saga_discovery_transaction_task_executor"><literal>SagaDiscoveryTransactionTaskExecutor</literal></link>
thread-pool, if the transaction is paused due a <link linkend="retryable_executor_exception"><literal>RetryableExecutorException</literal></link>, the transaction should be retried again after some time (configured schedule).
For those executions, the <literal>SagaDiscoveryRetryTransactionTaskExecutor</literal> thread-pool is used.</simpara>
<note>
<simpara>It ensures the application&#8217;s resiliency.
And also the application can receive the new transaction without interrupting the transaction retry-bulk.
The summary is that the retry execution does not disturb to the brand-new transaction.</simpara>
</note>
<simpara>— In case if you want to customize the default configuration, you can update the default configuration as follows:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Component <co xml:id="CO20-1"/>
public class CustomSagaDiscoveryRetryTransactionTaskExecutor
    implements SagaDiscoveryRetryTransactionTaskExecutorProvider {<co xml:id="CO20-2"/>

    @Override
    public ThreadPoolTaskExecutor getTaskExecutor() {
        <co xml:id="CO20-3"/>
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(Runtime.getRuntime().availableProcessors() * 5);
        ...
        return executor;
    }
}</programlisting>
<calloutlist>
<callout arearefs="CO20-1">
<para>Mark the class as a spring <literal>@Component</literal> (bean).</para>
</callout>
<callout arearefs="CO20-2">
<para>Implement the custom task-executor provider class from <literal>SagaDiscoveryRetryTransactionTaskExecutorProvider</literal> and override the <literal>getTaskExecutor()</literal> method.</para>
</callout>
<callout arearefs="CO20-3">
<para>Provide your custom task-executor configurations by creating a new instance of <link xl:href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/concurrent/ThreadPoolTaskExecutor.html"><literal>ThreadPoolTaskExecutor</literal></link>.</para>
</callout>
</calloutlist>
<note>
<simpara>Even though you change the prefix of the thread-pool when the task-executor is created, the prefix is restored for maintaining the thread-name uniqueness. <link linkend="custom_thread_pool_configuration">See the prefix of each thread-pool</link>.</simpara>
</note>
<simpara><?asciidoc-hr?></simpara>
</section>
</section>
<section xml:id="connect_admin">
<title>Connect Admin</title>
<simpara>As per the architecture, all the StackSaga clients connect to the StackSaga admin server initially (<emphasis role="strong">for submitting the instance metadata</emphasis>) and as well as during the StackSaga-client is being run (<emphasis role="strong">for submitting the terminated transaction data</emphasis>).</simpara>
<simpara>IF you want to connect your service with the StackSaga admin server, you have to have a <emphasis role="strong">service-account</emphasis> that has been created by the StackSaga admin.
IF you have a <emphasis role="strong">service-account</emphasis>, you can provide your service-account username and password for the basic authentication purpose.</simpara>
<note>
<simpara>In the microservice architecture, you will have hundreds of instances running on.
It is enough to have a one service-account for one service-name.
(The <literal>spring.application.name</literal> is considered as the service-name.)</simpara>
</note>
<simpara>After creating the <literal>service-account</literal>, you will have the basic authentication for the registered service.
Those basic authentication can be provided as follows in the configuration property file:</simpara>
<programlisting language="properties" linenumbering="unnumbered">stacksaga.connect.admin-url=http://localhost:4444
stacksaga.connect.admin-username=order-service
stacksaga.connect.admin-password=*****************</programlisting>
<note>
<simpara>The default StackSaga-Admin-server running on port <emphasis role="strong">4444</emphasis>.</simpara>
</note>
<section xml:id="custom_admin_connect_resttemplate_configuration">
<title>Custom Admin Connector configuration</title>
<simpara>In addition to the default configurations, if you want to provide more complex configurations for the http client (RestTemplate) like enable custom SSL configurations, You can provide your own <literal>RestTemplate</literal> for the StackSaga framework to use when the client connects to the admin-server.
Then the default configuration (<literal>SagaAdminConnectRestTemplateProviderDefault</literal>) will be overridden with your custom configurations.</simpara>
<simpara>— you can provide your custom configuration like below:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Component <co xml:id="CO21-1"/>
public class CustomAdminConnectRestTemplate implements SagaAdminConnectRestTemplateProvider {<co xml:id="CO21-2"/>
    @Override
    public RestTemplate getRestTemplate() {
        <co xml:id="CO21-3"/>
        RestTemplate restTemplate = new RestTemplate();
        //provide your custom configurations
        return restTemplate;
    }
}</programlisting>
<calloutlist>
<callout arearefs="CO21-1">
<para>Annotate the <literal>CustomAdminConnectRestTemplate</literal> class with spring <literal>@Component</literal> annotation.</para>
</callout>
<callout arearefs="CO21-2">
<para>Implement the custom RestTemplate provider class from <literal>SagaAdminConnectRestTemplateProvider</literal> and override the <literal>getRestTemplate()</literal> method.</para>
</callout>
<callout arearefs="CO21-3">
<para>Provide the custom RestTemplate with your own configurations.</para>
</callout>
</calloutlist>
<warning>
<simpara>Make sure to add the <literal>rootUri</literal> of the Admin-server to the new restTemplate.</simpara>
</warning>
<tip>
<simpara>If you want to get the admin-server connection configuration from the configuration file for your <literal>CustomAdminConnectRestTemplate</literal> class, you can autowire <literal>StackSagaAdminConfiguration</literal> and get the configurations from it.</simpara>
</tip>
</section>
</section>
<section xml:id="service_communication">
<title>Internal Service Communication</title>
<simpara>As per the StackSaga architecture, Internally (<emphasis role="strong">within the same zone</emphasis>) each instance should be able to communicate with other instances at any time.
Because, Any instance can be the Master instance and then the Master instance should have to make requests to other slaves to notify the retry-allocations.
The communication is done by based on the service registry cache of the current master.</simpara>
<note>
<simpara>Nature of Communication: If your microservices communicate with each other only within a trusted network (such as an internal data center with <link xl:href="https://docs.aws.amazon.com/vpc/latest/userguide/what-is-amazon-vpc.html">VPC network</link>), the need for SSL might be reduced.</simpara>
</note>
<section xml:id="eureka_configuration_for_stacksaga">
<title>Eureka configuration for StackSaga</title>
<simpara>If you ara using <literal>stacksaga-spring-boot-starter-discovery</literal>, To communicate with the slaves, the master instance uses a <literal>RestTemplate</literal> internally with the following configurations.</simpara>
<simpara>— Here you can see the required configurations with default values.</simpara>
<programlisting language="properties" linenumbering="unnumbered"><co xml:id="CO22-1"/>
eureka.instance.metadata-map.stacksagaManagementScheme=http
<co xml:id="CO22-2"/>
eureka.instance.metadata-map.stacksagaManagementBasePath=/actuator
<co xml:id="CO22-3"/>
eureka.instance.metadata-map.stacksagaRegion=defaultRegion
<co xml:id="CO22-4"/>
eureka.instance.metadata-map.stacksagaZone=defaultZone
<co xml:id="CO22-5"/>
eureka.instance.metadata-map.stacksagaManagementPort=0</programlisting>
<calloutlist>
<callout arearefs="CO22-1">
<para><emphasis role="strong">stacksagaManagementScheme</emphasis>: Scheme of the management service.</para>
<simpara>The default value is <emphasis role="strong">http</emphasis>.
If you want to enable <emphasis role="strong">https</emphasis>, you have to provide it through the configuration here.</simpara>
</callout>
<callout arearefs="CO22-2">
<para><emphasis role="strong">stacksagaManagementBasePath</emphasis>: Base path of the management service.</para>
<simpara>The default value is <emphasis role="strong">/actuator</emphasis>.
If you change the default value of the actuator(<literal>management.endpoints.web.base-path</literal>), make sure to provide it for Stacksaga as well.</simpara>
</callout>
<callout arearefs="CO22-3">
<para><emphasis role="strong">stacksagaRegion</emphasis>: Which is the region that the instance is currently running on.
The default value is <emphasis role="strong">defaultRegion</emphasis>.</para>
</callout>
<callout arearefs="CO22-4">
<para><emphasis role="strong">stacksagaZone</emphasis>: Which is the zone that the instance is currently running on.
The default value is <emphasis role="strong">defaultZone</emphasis>.</para>
</callout>
<callout arearefs="CO22-5">
<para><emphasis role="strong">stacksagaManagementPort</emphasis>: The management service port.
If you change the default management port in actuator (<literal>management.server.port</literal>) you have to provide it for Stacksaga as well.</para>
<note>
<simpara>By default, the server port and the management service port will be the same in spring.</simpara>
</note>
</callout>
</calloutlist>
<section xml:id="custom_service_communication_resttemplate_configuration">
<title>Custom Service Communication configuration</title>
<simpara>In case if you want to have more complex configurations more than default configurations like enabling custom SSL, adding authentication, you can provide your own RestTemplate for the framework like below:</simpara>
<programlisting language="java" linenumbering="unnumbered">@Component <co xml:id="CO23-1"/>
public class CustomServiceCommunicationRestTemplate implements SagaServiceCommunicationRestTemplateProvider { <co xml:id="CO23-2"/>
    private final RestTemplateBuilder restTemplateBuilder;

    <co xml:id="CO23-3"/>
    @Override
    public RestTemplate getRestTemplate() {
        <co xml:id="CO23-4"/>
        //provide your custom configurations
        RestTemplate restTemplate = this.restTemplateBuilder
                ...
                .build();
        return restTemplate;
    }
}</programlisting>
<calloutlist>
<callout arearefs="CO23-1">
<para>Annotate your custom class as a spring been with <literal>@Component</literal> annotation.</para>
</callout>
<callout arearefs="CO23-2">
<para>Implement the custom class from <literal>SagaServiceCommunicationRestTemplateProvider</literal> interface.</para>
</callout>
<callout arearefs="CO23-3">
<para>Override the <literal>getRestTemplate()</literal> method.</para>
</callout>
<callout arearefs="CO23-4">
<para>Provide your <literal>RestTemplate</literal> with your own custom configurations.</para>
</callout>
</calloutlist>
<warning>
<simpara>Make sure to not provide <literal>rootUri</literal> with your <literal>RestTemplate</literal> configurations.
Because the URL is built based on the <link linkend="eureka_configuration_for_stacksaga">configuration properties</link> and Eureka service-registry internally.</simpara>
</warning>
</section>
</section>
</section>
</chapter>
<chapter xml:id="stacksaga_starter_db_index">
<title>StackSaga Starter DB</title>

</chapter>
<chapter xml:id="stacksaga_starter_discovery_index">
<title>StackSaga Starter Discovery</title>

</chapter>
</book>